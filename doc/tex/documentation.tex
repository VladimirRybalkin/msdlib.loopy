\documentclass{report}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english,german]{babel}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
\usepackage[nameinlink]{cleveref}
%\usepackage{alltt}
%\usepackage{multirow}
%\usepackage{rotating}
\usepackage{listings}
\usepackage{setspace}

%\usepackage{fancyhdr}
%\setlength{\headheight}{15.2pt}

\usepackage[%gray,
      dvipsnames,svgnames]{xcolor}
\definecolor{light-green}{rgb}{0.9,1,0.85}

\usepackage{tikz}
\usetikzlibrary{matrix,arrows,shadows,positioning,fit,calc,decorations.pathreplacing,decorations.pathmorphing,decorations.shapes,decorations.text,automata}
\tikzset{math mode/.style = {execute at begin node=$, execute at end node=$}}

%tikz
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% boxes
\tikzstyle{class}=[draw, text width=6em, minimum height=2.5em, text centered]
\tikzstyle{tool}= [draw, text width=8em, minimum height=2.5em, text centered, draw=RoyalBlue, fill=blue!15 ]
\tikzstyle{file} = [draw, text width=8em, minimum height=2.5em, text centered, draw=ForestGreen, fill=light-green, rounded corners]
\tikzstyle{group}=[inner sep=10pt,draw=gray, very thick, dotted, rounded corners=4pt]

% arrows
\tikzstyle{arr}=[->, >=stealth', thick, gray, shorten >= 0.2mm]
\tikzstyle{aggregate}=[arr, >=open diamond]
\tikzstyle{extend}=[arr, >=open triangle 90]
%others
\tikzstyle{ann} = [above, text width=5em, text centered]

\lstset{literate=%
{√ñ}{{\"O}}1
{√Ñ}{{\"A}}1
{√ú}{{\"U}}1
{√ü}{{\ss}}2
{√º}{{\"u}}1
{√§}{{\"a}}1
{√∂}{{\"o}}1
{ùú∫}{{$\epsilon$}}1
{‚àß}{{$\wedge$}}1
{‚à®}{{$\vee$}}1
}

%listing languages
%\lstdefinelanguage{xcend}{
%  keywords={element, attribute, assert, exists, not exists, size, count, sum, tally, insert, update, delete, if, then, else, fi, at, to, %using},
%  comment=[l]{//},morecomment=[n]{/*}{*/}
%}

%\lstdefinelanguage{java}{backgroundcolor=\color{light-green}}

\lstset{
   %language=katja,
   basicstyle=\footnotesize,
   backgroundcolor=\color{light-green},
   frame=single,
   framerule=0pt
}

\renewcommand\arraystretch{1.2}

\brokenpenalty=1000
\widowpenalty=1000
\clubpenalty=1000

\begin{document}

\selectlanguage{english}
\title{HOPP Driver Generator Documentation}
\author{Thomas Fischer}
\date{\today}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\thispagestyle{empty}
\newpage



\chapter{Introduction}
\label{sec:intro}
This document is intended to give an overview over the HOPP Driver Generator for both, users and developers. While the first chapters are more addressed towards users of the generator, the later ones are more addressed towards developers. 

%define scope of the generator
The HOPP Driver Generator itself is intended to provide embedded system developers %that's kinda vague
with a simple, convenient interface to communicate with their designed hardware components. % that's not better...

\textcolor{red}{This sentence is just some test for bibliography management...} \cite{fischer12}.

\section{Origins and Goals}
\label{sec:goals}
\textcolor{red}{probably better filled out by the EIT department ;)}

\section{Terminology}
\label{sec:term}
This section explains the terminology used in this document and the project in general.

\paragraph{Board / board-side}
The driver is split in two parts, one of which has to be uploaded and executed to the fpga itself. This part of the driver is referred to as board-side driver. Sometimes, the terms \textit{server} and \textit{server-side} might be used instead.

\paragraph{Host / host-side}
In contrast to the board-side driver, the host-side driver is the part of the driver which is located on the communicating computer. Sometimes, the term \textit{client} and \textit{client-side} might be used instead.



\chapter{Getting Started}
\label{sec:start}
The purpose of this chapter is to explain how to properly build and use the generator. This part contains all steps required in order to run the generator and acquire drivers for the specified board.

\section{Setup}
\label{sec:setup}
In the following, the tools required to build and execute the driver generator are introduced. Please note, that all tools have to be executable from the command line. This requires (for example) Windows users to adjust their \texttt{PATH} variable.

\paragraph{Java}
The generator is implemented in Java due to tool support and the environment of the Software Technology Group. Consequently, a JDK version 6 or above is required. 

\paragraph{Gradle}
Gradle\footnote{available at \url{http://www.gradle.org/}} is a build tool, similar to \textit{Maven} or \textit{Ant} (like \textit{Make}, but - for the most part - easier to manage within larger projects). It supports the dependency management from Maven while retaining the flexibility of Ant. Plugins required by the build process are automatically downloaded by Gradle.

\paragraph{Mercurial}
Mercurial\footnote{available at \url{http://mercurial.selenic.com/}} is a distributed versioning tool, comparable with \textit{GIT}, \textit{Bazar} or \textit{Subversion}. The sources of the driver generator are located in a mercurial repository. If you acquired the sources (and this document) through other means mercurial is not required.

\paragraph{Doxygen}
Doxygen\footnote{available at \url{http://www.doxygen.org/}} is used for generation of a Javadoc-like html description of the driver api. While this generation is not required for the driver, it is highly recommended for easier integration of the generated driver.

\section{Process}
\label{sec:process}
If the tools described in \Cref{sec:setup} are correctly installed, the following steps should provide you with a working version of the driver generator.

\subsection{Building the Generator}
First of all, the project has to be checked out. As of now, the project is only available at the mercurial repository of the Softech Group of the University of Kaiserslautern.\footnote{The repository is located at \url{https://softech.informatik.uni-kl.de/hg/ag/hopp/}. Please note, that authorization is required.}

After checking out the project, all sources have to be compiled and packaged. This can be done using the gradle build tool. The command to build a jar package is \texttt{gradle jar}. Simply type it in a shell in the project root repository, where the file \texttt{build.gradle} is located. Running the build file will generate an executable jar package under the path \texttt{<project>/build/libs}. Navigate there and try running it using the command \texttt{java -jar <name of the jar package>}.\footnote{This should result in the usage help and an error, since no .mhs file has been specified.} 

\subsection{Running the Generator}
The HOPP Driver Generator can be called using the command line interface (CLI). The CLI offers several parameters to further configure the run of the generator, listed in \Cref{tab:cliParams}.

\begin{table}
\centering
\begin{tabular}{ ll | p{9cm} } 
\hline
%\verb!-d! & \verb!--dest! & Specifies the destination directory. All files will be generated into the specified directory. If none is specified, the current working directory will be used instead.\\ \hline
\verb!-s! & \verb!--server! & Specifies the destination of the server directory. All files for the server (i.e. files used to generate the board side driver) will be generated into the specified directory. If none is specified, a directory "server" will be generated inside the current working directory.\\
\verb!-c! & \verb!--client! & Specifies the destination of the client directory. All client for the server will be generated into the specified directory. If none is specified, a directory "client" will be generated inside the current working directory.\\ \hline
\verb!-v! & \verb!--verbose! & The driver generator will print out additional console output. This makes it easier to track errors in the driver generator or the used source file.\\
\verb!-d! & \verb!--debug! & The driver will be generated with additional debug console output. This makes it easier to track errors in larger test cases.\\ \hline
& \verb!--mac! & used to set the mac address of a possible Ethernet interface of the board. Notation: XX:XX:XX:XX:XX:XX, where each X marks a hexadecimal number (allowing lower as well as upper cases).\\
& \verb!--ip! & used to set the ip address of a possible Ethernet interface of the board. Notation: X.X.X.X, where each X marks a decimal number ranging from 0 to 255. The same notation is required for the following two parameters.\\
& \verb!--mask! & used to set the network mask of a possible Ethernet interface of the board.\\
& \verb!--gw! & used to set the standard gateway of a possible Ethernet interface of the board.\\
& \verb!--port! & used to set the communication port of a possible Ethernet interface of the board. \color{red}{Note that these five parameters are only contemporary and will be replaced by the new board description language (I hope - together with the debug parameter. It may be used for actually debugging the generator then ...).}\\ \hline
\verb!-h! & \verb!--help! & Lists all CLI parameters and a short explanation. The generator will abort after parsing this parameter and not generate anything.\\ \hline
\end{tabular}
\caption{Summary of currently possible CLI parameters}
\label{tab:cliParams}
\end{table}

Additionally, the \texttt{.mhs} file of the system is required by the generator. So a complete call looks like \texttt{java -jar driverGenerator.jar [OPTIONS] <.mhs file>}.

The output of the generator consists of two groups of files. The first group contains all files that make up the board side of the driver, which have to be compiled to an \texttt{.elf} file by the Xilinx SDK. The second group are files for the client side, that can be used to wrap communication with the board and its components.

In addition to the required sources, documentation for both host- and board-side sources is generated, using doxygen.

\chapter{Driver Description}
This section should provide a conceptual overview of the driver parts. For pure users of the driver generator, only parts of the client side are really relevant. Developers might also be interested in the server part.

For a more detailed documentation of the code and provided methods, Javadoc style comments are provided, which can be transformed into an html or tex representation similar to the Java API specification using doxygen (see \Cref{sec:start} for details on how to enable documentation generation).

\section{Host Side}
The client side consists of several cpp sources and headers files. These files can be imported in any client side project and be used to wrap communication with components on the board.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);
\node[class] (component) at (0,0) {Component};
\node[class, below left=5em and 6em] (interface) at (component) {Interface};
\node[class, below right=5em and 6em] (port) at (component) {Port};

\node[above=6em] (anchor_comp_if) at (interface) {};
\node[above=6em] (anchor_comp_port) at (port) {};

\node[class, gray, below=9em] (uart) at (interface) {USB/UART};
\node[class, gray, left=4em] (ethernet) at (uart) {Ethernet};
\node[class, gray, right=4em] (pcie) at (uart) {PCIE};

\node[above=2em] (anchor_ethernet) at (ethernet) {};
\node[above=2em] (anchor_uart) at (uart) {};
\node[above=2em] (anchor_pcie) at (pcie) {};

\node[class, gray, below left=4em and 0.5em] (in) at (port) {IN};
\node[class, gray, below right=4em and 0.5em] (out) at (port) {OUT};
\node[class, gray, below=9em] (dual) at (port) {DUAL};

\node[below=2.75em] (anchor_port) at (port) {};
\node[above=1.75em] (anchor_in_a) at (in) {};
\node[above=1.75em] (anchor_out_a) at (out) {};

\node[above=1.75em] (anchor_dual) at (dual) {};
\node[below=2.5em] (anchor_in_b) at (in) {};
\node[below=2.5em] (anchor_out_b) at (out) {};

\draw[arr, -, shorten >= -0.4em] (interface) to node[auto] {} (anchor_comp_if);
\draw[arr, -, shorten >= -0.4em] (port) to node[auto] {} (anchor_comp_port);

\draw[aggregate, shorten <= -0.35em] (anchor_comp_if) to node[auto] {} (component);
\draw[aggregate, shorten <= -0.35em] (anchor_comp_port) to node[auto] {} (component);

\node[ann, above left = 0em and 2.5em] (arr1) at (component) {1};
\node[ann, above right = 0em and 2.5em] (arr2) at (component) {1};

\node[ann, above right= 1.5em and -2em] (arr3) at (interface) {1};
\node[ann, above right = 1.5em and -1.5em] (arr4) at (port) {1..n};

\draw[arr,-, shorten >= -0.4em] (ethernet) to node[auto] {} (anchor_ethernet);
\draw[arr,-, shorten >= -0.4em] (pcie) to node[auto] {} (anchor_pcie);
\draw[arr,-, shorten >= -0.4em, shorten <= -0.4em] (anchor_ethernet) to node[auto] {} (anchor_pcie);
\draw[extend] (uart) to node[auto] {} (interface);

\draw[arr,-,shorten >= -0.4em] (in) to node[auto] {} (anchor_in_a);
\draw[arr,-,shorten >= -0.4em] (out) to node[auto] {} (anchor_out_a);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_a) to node[auto] {} (anchor_out_a);
\draw[extend, shorten <= -0.4em] (anchor_port) to node[auto] {} (port);

\draw[arr,-,shorten >= -0.4em] (dual) to node[auto] {} (anchor_dual);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (anchor_out_b);
\draw[extend, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (in);
\draw[extend, shorten <= -0.4em] (anchor_out_b) to node[auto] {} (out);

\end{tikzpicture}
\caption{Architecture of the host part \textcolor{red}{(to come)}}
\label{fig:archHost}
\end{figure}

The (intended) architecture of the host software is depicted in \Cref{fig:archHost}. The core concept of the host software is the \textit{component}. Such a component is a designed hardware unit, which can have several \textit{ports}, over which data can be sent to or received from the component. Hidden from the user, a component also has exactly one \textit{interface}, which handles actual communication.

\subsection{Component}
A component is a piece of designed hardware. It has multiple ports over which communication can take place, i.e. date is sent from or to the component, esp. the control ports \textit{clock} and \textit{reset}. Usually components receive data, process it and send back some results, though possibly on another port.

Components have to be described in VHDL for embedded system design with the Xilinx toolsuite. Such VHDL definitions can be referenced in the board description language provided by the HOPP Driver Generator. They are parsed and translated into corresponding software components with ports as defined in VHDL.

\subsection{Port}
Ports are used to send data to or receive data from components. A port is always assigned to a single component, but a component can have multiple ports. Ports can be receiving ports, sending ports or dual ports. They can have an arbitrary bitwidth. Since the bitwidth of the microblaze as well as the arm processor is limited to 32-bit, the port class has to split greater bitwidths in several 32-bit packages, but hide this process from the user. The encoding format, i.e. order of bits, also is hidden from the user.

\subsection{Communication Interface}
The communication interface is hidden from the user. Each component has exactly one such interface and a communication interface has to be attached to a component. The communication interface wraps all communication between host software and board software. The interface abstracts from the physical network interface and provides a homogeneous api for components and ports. Network interface specific initialization is generated as well and is not required by the user (other than annotating configuration details in the board description).

Note, that a board is also only allowed to use a single interface. Consequently, components using the same interface are physically located on the same board.

Currently, three communication interfaces are envisioned:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{Ethernet}, which is already implemented
\item \textbf{USB/UART}, which is considered as second interface and
\item \textbf{PCIE}, which will not be implemented in the initial driver generator.
\end{itemize}

\paragraph{Ethernet}
Communication over Ethernet is based on the lightweight IP stack, originally developed by Adam Dunkels\footnote{The lwip stack is documented with a wiki available at \url{http://lwip.wikia.com/wiki/LwIP_Wiki}}.

\textcolor{red}{Describe implementation of general interface methods in Ethernet as well as challenges and problems this interface poses.}

\section{Board Side}
For the board, only two relevant files are generated, a header and a plain c source file. Both files have to be imported in a new Xilinx SDK project started from an existing XPS project. The \texttt{.elf} file generated from this project then has to be uploaded to the target board.



\chapter{Generator}
This chapter is used to introduce the C generation backend. \textcolor{red}{A reference to the third Katja report might be useful.}

\section{Used Tools}
This section gives a short overview over the used libraries and explains what for and why they are used. These libraries are included in the repository and build jar file and require no further user interaction.

\subsection{JFlex \& Cup}
\textcolor{red}{This can be kept short with a reference to the JFlex/Cup documentation}

\subsection{Katja}
The driver generator uses the Katja tool, developed by the Software Technology Group of the University of Kaiserslautern. This tool generates several data types\footnote{Since these data types will be described using their Katja specifications, it is strongly recommended to read through the Katja specification provided in form of three technical reports at \url{https://softech.informatik.uni-kl.de/Homepage/Katja}}. To be more specific, it provides the AST build up by the CUP parser as well as a model of the C/C++ language described in detail in \Cref{sec:cmodel}.

\section{Process}
\label{sec:process}
The overall process of the driver generator is described by \Cref{fig:process}. The source \texttt{.mhs} file describing the system board design is first translated into an internal representation of the board, i.e. an abstract syntax tree. This AST is used as input for the generator, which in turn outputs all required header- and source files.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);
\node[tool] (gen) at (0,0) {Generator};

\node[file, above=1cm] (ast) at (gen) {Board AST};
\node[tool, above=1cm] (parser) at (ast) {Parser};
\node[file, above=1cm] (mhs) at (parser) {.mhs file};

%TODO there is probably a better way to draw this with tikz - but there always is a better way ;)
\node[file, below left = 1.5cm and 0cm of gen] (board3) {};
\node[file, above right = -2.8em and -9em of board3] (board2) {};
\node[file, above right = -2.8em and -9em of board2] (board1) {board files};

\node[file, below right = 1.5cm and 0cm of gen] (host3) {};
\node[file, above right = -2.8em and -9em of host3] (host2) {};
\node[file, above right = -2.8em and -9em of host2] (host1) {host files};

\node[group, fit=(board1) (board2) (board3), label={95:board side}] (board) {};
\node[group, fit=(host1) (host2) (host3), label={75:host side}] (host) {};

\draw[arr] (mhs) to node[auto] {input} (parser);
\draw[arr] (parser) to node[auto] {generates} (ast);
\draw[arr] (ast) to node[auto] {input} (gen);
\draw[arr] (gen) to node[left] {generates} (board);
\draw[arr] (gen) to node[right] {generates} (host);

\draw[arr, <->] (board) to node[below] {communicate} (host);
\end{tikzpicture}
\caption{A rough sketch of the translation process so far}
\label{fig:process}
\end{figure}

\section{CModel}
\label{sec:cmodel}
The c model provides data types representing a c/c++ program. Note, that the model is neither complete nor always valid, i.e. not all c programs can be described using this model and it is possible to specify a model not translating into valid c. Still, the model simplifies the process of code generation. The model is used for generating C as well as C++ code.

\begin{lstlisting}[language=java, breaklines=true]
MFile ( String name, MDefinitions defs, MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses classes )

MClass ( MDocumentation doc, MModifiers modifiers, String name, MTypes extend, 
	 MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses nested )

MModifier = PRIVATE() | PUBLIC() | CONSTANT() | STATIC() | INLINE()
\end{lstlisting}

First of all, each file has a name. A file consists of several definitions, structures, enums, attributes and methods. Files also can contain several classes. These classes again have a name and can contain all these components including other classes. In addition, classes can contain modifiers and inherit components from other classes. Classes also can be documented using an \texttt{MDocumentation} element.
The allowed modifiers are private, public, constant, static, and inline. Note, that not all of these modifiers are class modifiers, and several combinations of modifiers are invalid (e.g. private and public). The model relies on the developer to choose modifiers according to the modified program part.

\begin{lstlisting}[language=java, breaklines=true]
MDefinition ( MDocumentation doc, String name, String value)
MStruct ( MDocumentation doc, MModifiers modifiers, String name, MAttributes attributes )
MEnum   ( MDocumentation doc, MModifiers modifiers, String name, Strings values )
\end{lstlisting}

Definitions, structs and enums mark rather trivial tuple productions. A definition simply assigns a name to a value. %something about structs
Enums list a number of possible values. All three can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MAttribute ( MDocumentation doc, MModifiers modifiers, MAnyType type, String name, MCodeFragment initial )
MCodeFragment ( String part, MIncludes needed )
\end{lstlisting}

Attributes are similar to definitions, but are typed and may also be left unassigned, using an empty code fragment. The \texttt{MIncludes} is required if the type of the attribute is not defined within this c file itself. They also can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MMethod ( MDocumentation doc, MModifiers modifiers, MReturnType returnType, String name, MParameters parameter, MCode body )

MReturnType = MAnyType | MVoid() | MNone()

MParameter ( MParamType refType, MAnyType type, String name )
MParamType  = VALUE() | REFERENCE() | CONSTREF()

MCode ( Strings lines, MIncludes needed )
\end{lstlisting}

Methods have a return type and a list of parameters. The method body is also more complex than a simple code fragment and can consist of several lines, which are not checked any further in this model. The return type can be any c type as well as void. For constructors in c++, the return type \texttt{MNone} is used. Parameters also have a type and name. Furthermore, the mode of parameter passing has to be specified.

\begin{lstlisting}[language=java, breaklines=true]
MAnyType = MType             ( String name )
         | MArrayType        ( MAnyType type, Integer length )
         | MPointerType      ( MAnyType type )
         | MConstPointerType ( MAnyType type )
\end{lstlisting}

The type system of the model supports arrays as well as (const) pointers. The basic type is the \texttt{MType}, which consists only of a string that has to reference an existing c type, e.g. "int" or "struct student". This type can then be extended using pointer or array types. So \texttt{MArrayType(MType("int"), 5)} would mark an integer array of length 5. Note, that these types are nested semantically rather than in the same order as in C. Consequently, a point type of a const pointer type of type integer will be translated into \texttt{int const ** a}.

\begin{lstlisting}[language=java, breaklines=true]
MDocumentation ( Strings doc, MTags tags )

MTag = PARAM      ( String name, Strings details )
     | RETURN     ( Strings details )
     | THROWS     ( String type, Strings details )
     | DEPRECATED ( Strings details ) 
     | SEE        ( String see )
\end{lstlisting}

For generation of the API, Javadoc style documentation has to be added to the model. A \texttt{MDocumentation} element contains documentation for the following block as well as possibly several tags. Tags can be parameter or return value descriptions of a method/procedure, descriptions for exception behaviour, deprecation descriptions or references to other elements of the code. The \texttt{JAVADOC\_AUTOBRIEF} option is set in the generated doxygen config files, resulting in the first sentence (concluded by a dot and following space or newline) will be used as short description for the documented program part. Since neither the driver generator nor doxygen perform sanity checks, we rely on the user to only introduce meaningful tags for a documentation element. Note further, that the order of tags influences the order of elements in the generated API description.

\section{Unparser}
Different unparsers are used, to translate the C model in actual code. For each instance of the model, a header file and a corresponding source file, either C or C++, has to be generated. These unparsers are called depending on the particular instance of the model. Files intended to be loaded to the board have to be plain C, files intended for the client side can also be C++ files. The unparsing itself is realized using the visitor pattern. Each visit method appends code to a string buffer depending on the visited element.

\paragraph{Header Unparser}
The header unparser is used for both, unparsing C as well as C++ code. Consequently, it doesn't filter any constructs, but accepts everything specifiable with the model.

This unparser generates only signatures for all methods and only the declarations of attributes and enums. However, the header file will contain all includes referenced within the model.

\paragraph{Plain C Unparser}
Since plain C doesn't have any concept of classes, using a model with classes in this unparser will result in exceptions. Otherwise, all components and combinations are accepted. The source file will only import the corresponding header file, no other headers or sourcefiles.

\paragraph{C++ Unparser}
For the C++ unparser, like with the header unparser, every component and combination is allowed. The source file will only import the corresponding header file, no other headers or sourcefiles.



\addtocontents{toc}{\protect\vspace*{\fill}}

\newpage
\pagestyle{empty}
\bibliography{bib}
\bibliographystyle{splncs03}
\end{document}