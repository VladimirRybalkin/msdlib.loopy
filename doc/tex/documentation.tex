\documentclass{report}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english,german]{babel}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
\usepackage[nameinlink]{cleveref}
%\usepackage{alltt}
%\usepackage{multirow}
%\usepackage{rotating}
\usepackage{listings}
\usepackage{setspace}
\usepackage{mathpartir}
\usepackage{bytefield}

%\usepackage{fancyhdr}
%\setlength{\headheight}{15.2pt}

\usepackage[%gray,
      dvipsnames,svgnames]{xcolor}
\definecolor{light-green}{rgb}{0.9,1,0.85}

\usepackage{tikz}
\usepackage[underline=false,rounded corners=true]{pgf-umlsd}

%tikzlibaries
\usetikzlibrary{backgrounds,shapes,matrix,arrows,shadows,positioning,fit,calc,decorations.pathreplacing,decorations.pathmorphing,decorations.shapes,decorations.text,automata}
\tikzset{math mode/.style = {execute at begin node=$, execute at end node=$}}

%layer definition (insert threadground from pgf-umlsd)
\pgfdeclarelayer{lower}
\pgfsetlayers{background,lower,threadground,main}

% boxes
\tikzstyle{class}=[draw, text width=6em, minimum height=2.5em, text centered]
\tikzstyle{tool}= [draw, text width=8em, minimum height=2.5em, text centered, draw=RoyalBlue, fill=blue!15 ]
\tikzstyle{file} = [draw, text width=8em, minimum height=2.5em, text centered, draw=ForestGreen, fill=light-green, rounded corners]
\tikzstyle{state}=[circle, draw, align=center, minimum height=4em, anchor=north, inner sep=0]
\tikzstyle{group}=[inner sep=10pt,draw=gray, very thick, dotted, rounded corners=4pt]
\tikzstyle{netCloud}=[draw, text width=4em, minimum width =10em, minimum height=2em, text centered, cloud, cloud puffs = 15]

% arrows
\tikzstyle{arr}=[->, >=stealth', thick, gray, shorten >= 0.2mm]
\tikzstyle{aggregate}=[arr, >=open diamond]
\tikzstyle{extend}=[arr, >=open triangle 90]
%others
\tikzstyle{ann} = [above, text centered]


\lstset{literate=
{√ñ}{{\"O}}1
{√Ñ}{{\"A}}1
{√ú}{{\"U}}1
{√ü}{{\ss}}2
{√º}{{\"u}}1
{√§}{{\"a}}1
{√∂}{{\"o}}1
{ùú∫}{{$\epsilon$}}1
{‚àß}{{$\wedge$}}1
{‚à®}{{$\vee$}}1
}

%listing languages
%\lstdefinelanguage{xcend}{
%  keywords={element, attribute, assert, exists, not exists, size, count, sum, tally, insert, update, delete, if, then, else, fi, at, to, %using},
%  comment=[l]{//},morecomment=[n]{/*}{*/}
%}

%\lstdefinelanguage{java}{backgroundcolor=\color{light-green}}

\lstdefinelanguage{bdl}{
  keywords={import,medium,schedule,core,instance,gpio,source,port,bind,cpu,
        debug,swqueue,hwqueue,poll,width,in,out,dual,mac,ip,mask,gate},
  comment=[l]{//},morecomment=[n]{/*}{*/}
}

\lstset{
   %language=katja,
   basicstyle=\footnotesize,
   backgroundcolor=\color{light-green},
   frame=single,
   framerule=0pt,
   breaklines=true
}

\renewcommand\arraystretch{1.2}

\brokenpenalty=1000
\widowpenalty=1000
\clubpenalty=1000

%% extension for pgf-umlsd v0.5 2009/09/30, which TeXLive comes along

%% \leftsidelabel{thread}{side}{label}
%% side: left right above below
%\newcommand{\sidelabel}[3]{
%    \stepcounter{seqlevel}
%    \path
%    (#1)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (messbeg) {};
%    \draw (messbeg) node[#2] {#3};
%}

%% \begin{altblock}{from}{condition}{to}
%% %%calls here
%% \end{altblock}
%\newenvironment{altblock}[3]{
%    \stepcounter{seqlevel}
%    \path
%    (#1)+(.1,-\theseqlevel*\unitfactor-\unitfactor) node (from) {}
%    (#3)+(-.1,-\theseqlevel*\unitfactor-\unitfactor) node (to) {};
%    \draw (from) node[above right] {[#2]};
%}{}

%% mostly used between altblocks
%% \separateline[line style]{from}{to}
%\newcommand{\separateline}[3][dotted, color=black, very thick]{
%    \stepcounter{seqlevel}
%    \path
%    (#2)+(.1,-\theseqlevel*\unitfactor-.8*\unitfactor) node (from) {}
%    (#3)+(-.1,-\theseqlevel*\unitfactor-.8*\unitfactor) node (to) {};
%    \draw[#1] (from) -- (to);
%}

%% inverse to prelevel - adds an empty line
%\newcommand{\postlevel}{\addtocounter{seqlevel}{+1}}

%% \newthread[thread distance]{left}{right}
%\renewcommand{\newthread}[3][0.2]{
%    \newinst[#1]{#2}{#3}
%    \stepcounter{threadnum}
%    \node[below of=inst\theinstnum,node distance=1em] (thread\thethreadnum) {};
%    \tikzstyle{threadcolor\thethreadnum}=[fill=gray!30]
%    \tikzstyle{instcolor#2}=[fill=gray!30]
%}

\begin{document}

\selectlanguage{english}
\title{HOPP Driver Generator Documentation}
\author{Thomas Fischer}
\date{\today}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\thispagestyle{empty}
\newpage


\chapter{Introduction}
\label{sec:intro}
This document is intended to give an overview over the HOPP Driver Generator for both, users and developers. While the first chapters are more addressed towards users of the generator, the later ones are more addressed towards developers. 

%define scope of the generator
The HOPP Driver Generator itself is intended to provide embedded system developers %that's kinda vague
with a simple, convenient API to communicate with their designed hardware components. % that's not better...
This interface provides methods for synchronous as well as asynchronous communication over different communication media, for example Ethernet.

To our knowledge, such an interface for communication with VHDL components has not been done so far, though extensive research exists concerning efficient communication between PCs and FPGAs over different communication channels, mainly Ethernet \cite{lofgren05, alachiotis10, alachiotis12}.

The architecture has been prototyped with a \texttt{C++} frontend communicating with a Xilinx Virtex 6 ML-605 FPGA over Ethernet. The design of the driver generator enables easy extension to support other frontend languages, FPGA boards or transport media.

\section{Origins and Goals}
\label{sec:goals}
The HOPP Driver Generator originally was and currently is developed by the Software Technology Group of the University of Kaiserslautern in cooperation with the Microelectronic Design Research Group of the University of Kaiserslautern.

The non-functional design goals of this project are:

\begin{itemize}
%those are not really "design" goals, but hey... text... for now
\item \textcolor{red}{Probably better filled out by the EIT department ;)}
\item An easy-to-use driver and driver generator
\item Well-documented api
\item Modularity and extensibility
\item Meaningful error description
\end{itemize}

\section{Terminology}
\label{sec:term}
This section explains the terminology used in this document and the project in general.

\paragraph{Driver}
The complete software product is called the \textit{driver}. It enables programmatic, \textcolor{red}{software-side} communication with the hardware platform.

\paragraph{Board / board-side}
The driver is split in two parts, one of which has to be uploaded and executed to the hardware platform itself. This part of the driver is referred to as board-side driver. Sometimes, the terms \textit{server} and \textit{server-side} might be used instead.

\paragraph{Host / host-side}
In contrast to the board-side driver, the host-side driver is the part of the driver which is located on the communicating computer. This part contains the actual API, embedded developers will work with. Sometimes, the terms \textit{client} and \textit{client-side} might be used instead.



\chapter{Getting Started}
\label{sec:start}
The purpose of this chapter is to explain how to properly build and use the generator. This part contains all steps required in order to run the generator and acquire drivers for the specified board.

\section{Setup}
\label{sec:setup}
In the following, the tools required to build and execute the driver generator are introduced. Please note, that all tools have to be executable from the command line. This requires (for example) Windows users to adjust their \texttt{PATH} variable.

\paragraph{Java}
The generator is implemented in Java due to tool support and the environment of the Software Technology Group. Consequently, a JDK version 6 or above is required. %I guess a JRE would suffice - if we provide the jar file instead of the source code ;)

\paragraph{Gradle}
Gradle\footnote{available at \url{http://www.gradle.org/}} is a build tool, similar to \textit{Maven} or \textit{Ant} (like \textit{Make}, but - for the most part - easier to manage within larger projects). It supports the dependency management from Maven while retaining the flexibility of Ant. Plugins required by the build process are automatically downloaded by Gradle.

\paragraph{Mercurial}
Mercurial\footnote{available at \url{http://mercurial.selenic.com/}} is a distributed versioning tool, comparable with \textit{GIT}, \textit{Bazar} or (to some degree) \textit{Subversion}. The sources of the driver generator are located in a mercurial repository. If you acquired the sources (and this document) through other means mercurial is not required.

\paragraph{Doxygen}
Doxygen\footnote{available at \url{http://www.doxygen.org/}} is used for generation of a Java API-like html description of the driver API. While this generation is not required for the driver, it is highly recommended for easier integration of the generated driver.

\paragraph{\texttt{C/C++} Compiler}
Since the host side driver is written in \texttt{C++}, it is also required to have a \texttt{C/C++} compiler present.

\paragraph{Xilinx Toolsuite}
In order to generate an \texttt{.elf} file that can is used to program the FPGA, the Xilinx toolsuite is required. This includes ISE for generating IPCores out of VHDL files, XPS for composing these and EDK for actually generating the file for the defined hardware platform.

 \textcolor{red}{We try to avoid to require the user to actually design anything in the Xilinx suite, but only use it for synthesising the board hard- and software. Both, \texttt{.mhs} file and all source files for the EDK, are created by the driver generator.}

\textcolor{red}{It is furthermore desirable to skip user-interfaction with the EDK completely. This would require generation of the board support package and external call of Xilinx' compiler.}

\section{Board Description Language}
In this section, the \textit{board description language} (abbreviated: \textit{bdl}) is introduced. The language is used to specify a board, for which a driver and project files should be generated. 

A board specification file consists of several \textit{declarations}, that may appear in arbitrary order. For improved readability of the board description file, it is advisable, to provide declarations in the same order as they are explained in this document.

In the declarations, the terms of \textit{blocks} and \textit{code blocks} are used. A block is used to wrap properties of a specific declaration in the file. It is surrounded with curly brackets \texttt{\{\}}.
A code block is a block that directly be induced in the driver, i.e., contains code in the target language of the driver. The code is surrounded by curly brackets and colons \texttt{\{::\}}.

\subsubsection{Import}
Import declarations reference additional board description files, that also should be used to generate the driver. The driver generator will collect all imported files recursively and compile one large driver out of all these files.

\begin{lstlisting}[language=bdl]
import "some/samplefile.bdf"
\end{lstlisting}

The declaration consists of the keyword \texttt{import} followed by a string containing the path of the file to be imported.

\subsubsection{Backend}
A backend declaration tells the driver generator, for which target platforms the driver should be generated.

%As of now, it is a bit unclear, how this will look like, i.e. which keywords, how many, what parameters, ...

Not all features that can be described using the bdl are necessarily supported by all backends. Check documentation of the backend implementations for details. Documentation of the prototype implementations for teh C++ host-side backend and the Virtex6ML605 board-side backend can be found in \Cref{sec:impl}

\subsubsection{Medium}
The medium declaration describes over which medium board and host should communicate with each other.

\begin{lstlisting}[language=bdl]
medium ethernet { ... }
\end{lstlisting}

It consists of the keyword \texttt{medium} followed by the medium identifier and a block describing medium-specific properties. Depending on the chosen medium, several properties are possible and required.

\paragraph{Ethernet}
The Ethernet medium is selected using the keyword \texttt{ethernet}. The following block has to specify the mac address, ip address, subnet mask, standard gateway and port number.

\begin{lstlisting}[language=bdl]
medium ethernet {
  mac  "00:0a:35:00:01:02"
  ip   "192.168.2.10"
  mask "255.255.255.0"
  gate "192.168.2.1"
  port 8844
}
\end{lstlisting}

All theses properties are specified in a rather intuitive way.

\paragraph{USB/UART}
Connection over USB/UART is done with the keyword \texttt{uart}. No property block is provided for this communication medium as no further configuration is required.

\begin{lstlisting}[language=bdl]
medium uart
\end{lstlisting}

\subsubsection{Scheduler}
With use of the scheduler declaration, it is possible to override the default scheduler on the board. This can improve general driver performance for specific applications.

\begin{lstlisting}[language=bdl]
schedule {: ... :}
\end{lstlisting}

The declaration consists of the keyword \texttt{schedule} followed by a code block containing the code of the user-defined scheduler.

Note, that no guarantees can be given for a user-defined scheduler. For a more detailed description of the default scheduler and actions required by a user-defined scheduler, check out the board-side control flow graphs in \Cref{sec:protocol:cfg}.

\subsubsection{Options}
Several global properties of the board are specified directly without using distinct blocks. At this time, this includes the debug flag and global queue sizes (see \Cref{sec:arch:queue} for more details about the different queue types).

\begin{lstlisting}[language=bdl]
debug
swqueue 128
hwqueue 32
\end{lstlisting}

The debug flag results in additional console output of the generated driver. Note, that this output is sent over UART and therefore significantly slows down the driver.

If not specified otherwise, debugging is disabled and the queue sizes are set to default (1024 for the software queue, 64 for the hardware queue).

\subsubsection{GPIO}
The GPIO declaration is used to add GPIO devices to the board design. These devices are integrated deeper in the board design and require explicit treatment.

\begin{lstlisting}[language=bdl]
gpio in buttons {:
  if(state == 1) reset();
  else if(state == 2) setLEDState(10);
:}
\end{lstlisting}

As all other declarations, the GPIO declaration begins with a keyword. The next part of the declaration is a direction specifier, telling the generator if the component is an input, output or dual component.
Afterwards, the identifier of the component is required. This identifier has to be known to the specified board backend.
Finally, an optional code block can be used to override board-side standard behaviour of the GPIO component. This code block is only valid for input components (or the input part of a dual component). The default behaviour for input components is forwarding of the value to the host-side driver.

\subsubsection{Core}
A core is a template for components on the board. It contains behaviour specification in form of vhdl files and a matching description of the interface.

\begin{lstlisting}[language=bdl]
core adder 1.00.a  {
  ...
}
\end{lstlisting}

A core is declared by the keyword \texttt{core} followed by the name of the core and a version string. Properties of the core are described within a following declaration block. This block consists of two parts. First is a list of sources, that describe the implementation of the core.

\begin{lstlisting}[language=bdl]
  source "cores/adder_1_00_a.vhd"
\end{lstlisting}

Source references are very similar to import declarations and only differ in the used keyword and allowed occurrences within the bdl file.

The second part of the core declaration block describes the interface of the core.

\begin{lstlisting}[language=bdl]
  port in in1, in2, in3
  port out out1 {
    width 16
  }
\end{lstlisting}

An interface description consists of several port declarations. A port is either in-going, out-going or dual. The port specification looks somewhat similar to the gpio declaration. The keyword \texttt{port} is followed by a direction specifier and an identifier. It is possible, to provide several, comma separated identifiers to declare several ports sharing the same properties. These properties are described in another block following the port declaration. This currently only includes the bitwidth of the port. The block can be omitted, resulting in standard values to be used. The default bitwidth of a port is 32-bit.

\subsubsection{Instance}
The instance declaration instantiates a core on the board. This effectively creates a component on the board with the behaviour and interface specified by the core. The interface declaration itself connects this component with other components.

\begin{lstlisting}[language=bdl]
instance adder adder1 {
  ...
}
\end{lstlisting}

An instance declaration begins with the keyword \texttt{instance}, followed by a reference to the used core and the identifier of the instance itself. A property block is used to make connections between the ports of the core instance with other core instances.

\begin{lstlisting}[language=bdl]
  bind in1 myAxis
  cpu in2, in3 {
    swqueue 10
    hwqueue 5
  }
  cpu out1 {
    poll
  }
\end{lstlisting}

The \texttt{bind} keyword connects a port with an axis. An axis is basically a connection between exactly two ports.
The keyword \texttt{cpu} connects the specified port to the board-side driver. %keyword questionable...
The host-side driver will provide methods for direct communication with these ports of the component. Another block is used for properties of these driver-attached ports.

Specifiable properties include queue sizes (see \Cref{sec:arch:queue}) and automatic value forwarding to the host-side driver (this will be explained in more detail in \Cref{sec:api:port}). If not specified otherwise, the global queue sizes of the board are used and forwarding is enabled.

\section{Process}
\label{sec:process}
If the tools described in \Cref{sec:setup} are correctly installed, the following steps should provide you with a working version of the driver generator.


%\begin{figure}
%\centering
%\begin{tikzpicture}
%\node[ann] (anchor) at (0,0) {};
%
%\node[class, below left = 0em and 4em] (build) at (anchor) {build generator (only once)};
%\node[class, below right = 0em and 4em] (dsl) at (anchor) {define VHDL files and DSL file};
%
%\node[class, below left = 6em and 4em] (gen) at (dsl) {run generator};
%\node[class, below right = 6e and 4em] (app) at (dsl) {write client application};
%
%\node[class, below left = 6em and 4em] (edk) at (gen) {build .elf with Xilinx EDK};
%\node[class, below right = 6em and 4em] (compile) at (gen) {compile composed application};
%
%\node[class, below left = 6em and 4em] (run) at (compile) {program fpga and run application};
%
%\draw[arr] (build) to node[auto] {} (gen);
%\draw[arr] (dsl) to node[auto] {} (gen);
%\draw[arr] (dsl) to node[auto] {} (app);
%
%\draw[arr] (gen) to node[auto] {} (edk);
%\draw[arr] (gen) to node[auto] {} (compile);
%\draw[arr] (app) to node[auto] {} (compile);group
%
%\draw[arr] (edk) to node[auto] {} (run);
%\draw[arr] (compile) to node[auto] {} (run);
%\end{tikzpicture}
%\label{fig:workflow}
%\caption{Workflow when using the driver generator}
%\end{figure}

\subsection{Building the Generator}
First of all, the project has to be checked out. As of now, the project is only available at the mercurial repository of the Softech Group of the University of Kaiserslautern.\footnote{The repository is located at \url{https://softech.informatik.uni-kl.de/hg/ag/hopp/}. Please note, that authorization is required.}

After checking out the project, all sources have to be compiled and packaged. This can be done using the gradle build tool. The command to build a jar package is \texttt{gradle jar}. Simply type it in a shell in the project root repository, where the file \texttt{build.gradle} is located. Running the build file will generate an executable jar package under the path \texttt{<project>/build/libs}. Navigate there and try running it using the command \texttt{java -jar <name of the jar package>}.\footnote{This should result in the usage help and an error, since no .mhs file has been specified.} 

\subsection{Running the Generator}
The HOPP Driver Generator can be called using the command line interface (CLI). The CLI offers several parameters to further configure the run of the generator, listed in \Cref{tab:cliParams}.

\begin{table}
\centering
\begin{tabular}{ ll | p{9cm} } 
\hline
%\verb!-d! & \verb!--dest! & Specifies the destination directory. All files will be generated into the specified directory. If none is specified, the current working directory will be used instead.\\ \hline
\verb!-s! & \verb!--server! & Specifies the server backend. This specifies, for which target platform the driver should be generated. The default setting is a Virtex 6 ML 605 FPGA (currently, no other options are present).\\
& \verb!--serverDir! & Specifies the destination of the server directory. All files for the server (i.e. files used to generate the board side driver) will be generated into the specified directory. If none is specified, a directory "server" will be generated inside the current working directory.\\ \hline
\verb!-c! & \verb!--client! & Specifies the client backend. This specifies, in which language the client software should be generated. The default setting is a C++ frontend (currently, no other options are present).\\
& \verb!--clientDir! & Specifies the destination of the client directory. All client for the server will be generated into the specified directory. If none is specified, a directory "client" will be generated inside the current working directory.\\ \hline
\verb!-v! & \verb!--verbose! & The driver generator will print out additional console output. This makes it easier to track errors in the driver generator or the used source file.\\
\verb!-d! & \verb!--debug! & The driver will be generated with additional debug console output. This makes it easier to track errors in larger test cases.\\
\verb!-h! & \verb!--help! & Lists all CLI parameters and a short explanation. The generator will abort after parsing this parameter and not generate anything.\\ \hline
& \verb!--mac! & used to set the mac address of a possible Ethernet interface of the board. Notation: XX:XX:XX:XX:XX:XX, where each X marks a hexadecimal number (allowing lower as well as upper cases).\\
& \verb!--ip! & used to set the ip address of a possible Ethernet interface of the board. Notation: X.X.X.X, where each X marks a decimal number ranging from 0 to 255. The same notation is required for the following two parameters.\\
& \verb!--mask! & used to set the network mask of a possible Ethernet interface of the board.\\
& \verb!--gw! & used to set the standard gateway of a possible Ethernet interface of the board.\\
& \verb!--port! & used to set the communication port of a possible Ethernet interface of the board. \color{red}{Note that these five parameters are only contemporary and will be replaced by the new board description language (I hope - together with the debug parameter. It may be used for actually debugging the generator then ...).}\\ \hline

\end{tabular}
\caption{Summary of currently possible CLI parameters}
\label{tab:cliParams}
\end{table}

%\begin{table}
%\centering
%\begin{tabular}{ ll | p{9cm} } 
%\hline
%\verb!-d! & \verb!--dest! & Specifies the destination directory. All files will be generated into the specified directory. If none is specified, the current working directory will be used instead.\\ \hline
%\verb!-p! & \verb!--project! & Specifies the project backend. This specifies, in which tool the hardware design should take place. Currently, only XPS in version 14.1 can be selected.\\
%\hline
%\end{tabular}
%\caption{Summary of currently possible options for the Virtex6 server backend}
%\label{tab:cppParams}
%\end{table}

Additionally, the \texttt{.mhs} file of the system is required by the generator. So a complete call looks like the following line:\\

\texttt{java -jar driverGenerator.jar [OPTIONS] <.mhs file>}.\\

The output of the generator consists of two groups of files. The first group contains all files that make up the board side of the driver, which have to be compiled to an \texttt{.elf} file by the Xilinx SDK. The second group are files for the client side, that can be used to wrap communication with the board and its components.

In addition to the required sources, documentation for both host- and board-side sources is generated, using doxygen.

\subsection{Executing your Application}
Now the regular design process from Xilinx can be continued. The next step would be writing a host application that uses the generated host-side driver and API. After programming your FPGA with the \texttt{.elf} file generated using the board-side driver, your program should be able to communicate with VHDL components on the FPGA through this API.

Note, that it is required to call the setup method before actually sending data over the driver. It is also recommended, to shut the driver threads down properly by using the provided shutdown method. Both these methods are \textcolor{red}{/will be} contained within the components file.

\chapter{Driver Description}
This section should provide a conceptual overview of the driver parts. For pure users of the driver generator, only parts of the client side are really relevant. Developers might also be interested in the server part.

For a more detailed documentation of the code and provided methods, Javadoc style comments are provided, which can be transformed into an html or tex representation similar to the Java API specification using doxygen (see \Cref{sec:start} for details on how to enable documentation generation).

\begin{figure}[h]
\centering

\begin{tikzpicture}
%maybe also add networking components here... i.e. split the driver in two components - one handling communication with application/hardware, one handling networking - with another clearly defined interface. This allows better modularity and exchange of both parts individually. For example one could switch the communication channel without having to completely recompile the client-side communication. The question will be, how this can be made easy-to-use... Still, this modularity will ensure, that other transport mediums can be easily implemented. So if a transport over PCIE should be realised later, it is clear what functionality has to be provided --> clear interface definition!!

\node[netCloud] at (0,0) (cloud) {Transport Medium};

\node[class,fill=red!15, right=9em] (cdriver) at (cloud) {host-side driver};
\node[class, above=4em] (client) at (cdriver) {host application};

\node[class,fill=red!15, left=9em] (bdriver) at (cloud) {board-side driver};
\node[class,fill=white, below=4em] (vhdl3) at (bdriver) {};
\node[class,fill=white, above right = -2.72em and -6.9em of vhdl3] (vhdl2) {};
\node[class,fill=white,  above right = -3em and -6.9em of vhdl2] (vhdl1) {VHDL components};

\node[group, fit=(client) (cdriver), label={85:host side}] (hostSide) {};
\node[group, fit=(bdriver) (vhdl3) (vhdl2) (vhdl1), label={93:board side}] (boardSide) {};

\draw[arr,<->] (client) to node [auto] {} (cdriver);
\draw[arr,<->] (cdriver) to node [auto] {} (cloud);
\draw[arr,<->] (cloud) to node [auto] {} (bdriver);
\draw[arr,<->] (bdriver) to node [auto] {} (vhdl3);
\end{tikzpicture}

\caption{A high-level view of the data flow from a host application to vhdl components on the board through the generated driver}
\label{fig:dataFlow}
\end{figure}

The overall architecture of the driver is depicted by \Cref{fig:dataFlow}. Data is sent from an embedding host application to the host-side driver. This driver communicates over some transport medium with the board-side driver, which in turn distributes the received data to corresponding VHDL components on the FPGA. Results are sent back through the same chain.

\section{API}
\label{sec:api}
This section describes, how the host-side API, the hardware designer programs his application against, should look like. This helps designers in writing their application and describes how host-side drivers in other languages should be implemented in general.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\coordinate(center);
\node[class] (component) at (0,0) {Component};
\node[class, right=15em] (port) at (component) {Port};

\node[class, gray, below left=4em and 0.5em] (in) at (port) {IN};
\node[class, gray, below right=4em and 0.5em] (out) at (port) {OUT};
\node[class, gray, below=9em] (dual) at (port) {DUAL};

\node[below=2.75em] (anchor_port) at (port) {};
\node[above=1.75em] (anchor_in_a) at (in) {};
\node[above=1.75em] (anchor_out_a) at (out) {};

\node[above=1.75em] (anchor_dual) at (dual) {};
\node[below=2.5em] (anchor_in_b) at (in) {};
\node[below=2.5em] (anchor_out_b) at (out) {};

\draw[arr,-] (port) to node[auto] {} (component);

\node[ann, above right = 0em and 3.8em] (ann1) at (component) {1};
\node[ann, above left = 0em and 3.8em] (ann2) at (port) {1..n};

\draw[arr,-,shorten >= -0.4em] (in) to node[auto] {} (anchor_in_a);
\draw[arr,-,shorten >= -0.4em] (out) to node[auto] {} (anchor_out_a);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_a) to node[auto] {} (anchor_out_a);
\draw[extend, shorten <= -0.4em] (anchor_port) to node[auto] {} (port);

\draw[arr,-,shorten >= -0.4em] (dual) to node[auto] {} (anchor_dual);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (anchor_out_b);
\draw[extend, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (in);
\draw[extend, shorten <= -0.4em] (anchor_out_b) to node[auto] {} (out);

\end{tikzpicture}
\caption{Exposed classes of the host part}
\label{fig:api:host}
\end{figure}

The exposed architecture of the host software is depicted in \Cref{fig:api:host}. A board is described using multiple \textit{components}. A component is a designed hardware unit, which can have several \textit{ports}, over which data can be sent to or from the component.

\subsection{Component}
\label{sec:api:component}
A component is a piece of designed hardware. It has multiple ports over which communication can take place, i.e. data is sent from or to the component. Usually components receive data, process it and send back some results, though on another port.

The host driver contains an abstract generic component, describing components in general. For each user-defined core, a new subclass is created, which contains the ports specified in the core description. For each instance of a core on the board, an object of the cores subclass together with all its ports is instantiated in the driver respectively. Communication with the boards components happens through these port objects.

Details about the implementation of components can be found in \Cref{sec:impl:cpp}.

\paragraph{GPIO compoments}
These components are specialised, predefined I/O components, used to directly input or output a signal on the board. The GPIO representation in the driver enables the host-side application to write or read this signal. 
A GPIO component is either used as input or output component.
An input component, enables input of a signal. An example for such a component is the pushbutton component on the Virtex 6.
An output component does the opposite and displays a signal on the board. The Virtex 6 has an LED component which is classified as output component. The signal to be displayed can be written to such a GPIO component.

Since such components only hold a single state and perform no processing, communication is not handled via ports. Instead, it is possible to directly read or write the state of the component. 

\subsection{Port}
\label{sec:api:port}
 A port marks an AXI stream interface used to send data to or receive data from components. A port is always assigned to a single component, but a component can have multiple ports. Ports can be sending (\textit{in-going}), receiving (\textit{out-going}) or bi-directional (\textit{dual}). These designations seem counter-intuitive at first, since they do not describe the ports on the host-side, but the ports of the driver itself. The user should work with the driver, as if it were the actual board. Consequently, data is sent to an in-going port an received from an out-going port. Values sent to or received from a port have an arbitrary, but fixed bitwidth. Ports are the only way to communicate with components or the board in general (beside aforementioned GPIO components). 

Ports allow \textit{synchronous} as well as \textit{asynchronous} communication. A synchronous write to a port waits for the message to be delivered to the component. A synchronous read waits for a value to be received. Asynchronous operations do not wait, but return immediately. Instead, a \textit{task} is scheduled for the operation, which will be performed asynchronously. While the order between tasks and therefore values to a single port is maintained, the order between tasks executed at different ports may differ from the order they were scheduled in.

Ports are generally \textit{forwarding}, meaning that values are send automatically from host to board and vice versa as soon as available. Out-going ports can be switched into \textit{polling} mode explicitly, resulting in values being not forwarded but only send if requested by the user. The interface of these ports looks identical and the difference is only visible in performance. A polling port is useful in cases, where the attached component generates values periodically without additional input, e.g., a random number generator.

Details about the implementation of ports can be found in \Cref{sec:impl:cpp}.

\subsection{State}
\label{sec:api:state}
Another important part of the API is the \textit{state}, which describes the current progress of a read or write operations. A state is returned by asynchronous operations and can be used to keep track of the operations progress. A \textit{write state} indicates, how many values have already been written to the board (and how many have not), a \textit{read state} indicates, how many values have already been read to the given memory area (and how many still remain).
Synchronous operations do not return a state, since such an operation is always finished, once it returns.

\section{Architecture}
\label{sec:arch}
%Queueing, threads, ... - basically, the picture from the whiteboard, as this is NOT a feature of the C++ implementation, but the essential part of the protocol architecture...
%Interesting for driver developers and people trying to extend the existing driver, NOT for users!

This section provides an overview of the drivers architecture, that should be followed by all implementations.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\coordinate(center);

\tikzstyle{outerClass}=[inner sep=8pt,draw=black]

\node[class, fill=white] (port1) at (0,0) {In Port};
\node[class, below = 2em, fill=white] (port2) at (port1) {In Port};
\node[class, below = 2em, fill=white] (port3) at (port2) {Out Port};

\node[ann, above left = 2em and -2.3em] (compText) at (port1) {Component};

\begin{pgfonlayer}{lower}
\node[outerClass, fit =(port1) (port2) (port3) (compText), fill=white] (comp) {};
\end{pgfonlayer}

\node[class, below right = 0em and 8em, fill=white] (writer) at (port1) {Writer};
\node[class, right = 8em, fill=white] (reader) at (port3) {Reader};

\draw[arr, black] (port1) to node[auto] {} (writer);
\draw[arr, black] (port2) to node[auto] {} (writer);
\draw[arr, black] (reader) to node[auto] {} (port3);

\begin{pgfonlayer}{background}
\node[group, fit = (comp) (reader), label={66:host-side driver}, fill=blue!10] (host) {};
\end{pgfonlayer}
\node[netCloud, below right =0em and 10em] (net) at (writer) {Transport Medium};

\draw[arr, black] (writer) to node[auto] {} (net);
\draw[arr, black] (net) to node[auto] {} (reader);

\path let \p1=(comp.west), \p2=(comp.east)
in node[class, above = 8em, minimum width=\x2-\x1-\pgflinewidth] (app) at (port1) {Application};

\draw[arr, black, <->] (app) to node[auto] {} (comp);
\end{tikzpicture}
\label{fig:arch:host}
\caption{General architecture of the host-side driver}
\end{figure}

The architecture of the host-side driver is depicted by \Cref{fig:arch:host}. The host-side API consists of the components and ports described in \Cref{sec:api}, as well as modules handling communication with the medium, i.e., a reader and a writer module. An application communicates with the driver through components and ports.

In-going ports are connected to the writer, while out-going ports are connected to the reader. Writer and reader are not exposed to the application and steps necessary for communication are performed internally.

\begin{figure}
\centering
\begin{tikzpicture}
\coordinate(center);

\tikzstyle{outerClass}=[inner sep=7pt,draw=black]

\node[netCloud] (net) at (0,0) {Transport Medium};

\node[class, below left= 8em and 2em, fill=white] (reader) at (net) {Reader};
\node[class, below right= 8em and 2em, fill=white] (writer) at (net) {Writer};

\draw[arr, black] (net) to node[auto] {} (reader);
\draw[arr, black] (writer) to node[auto] {} (net);

\node[class, below = 3em, fill=white] (axiw) at (reader) {AXI Writer};
\node[class, below = 3em, fill=white] (axir) at (writer) {AXI Reader};

\draw[arr, black] (reader) to node[auto] {} (axiw);
\draw[arr, black] (axir) to node[auto] {} (writer);

\begin{pgfonlayer}{lower}
\node[group, fit=(reader) (axir), label={70:board-side driver}, fill=blue!10] (board) {};
\end{pgfonlayer}

\node[ann, above left=3em and -0.5em] (procText) at (reader) {Processor};

\begin{pgfonlayer}{background}
\node[outerClass, fit=(procText) (board)] (proc) {};
\end{pgfonlayer}

\node[class,  below= 6em] (comp) at (board) {board-side components};

\draw[arr, black] (axiw) to node[auto] {} (comp);
\draw[arr, black] (comp) to node[auto] {} (axir);

\end{tikzpicture}
\label{fig:arch:board}
\caption{General architecture of the board-side driver}
\end{figure}

The architecture of the board-side driver is depicted by \Cref{fig:arch:board}.
The board side driver is basically a thread running on the processor of the board. It handles communication with the medium similar as the host-side driver through a writer and a reader module. Another module handles communication with the components implemented on the board. %(connected over AXI stream in our case, but could also be something else)
In our case, the components are attached with AXI stream interfaces, but using other interfaces is generally possible. %though not with the current implementation

\subsection{Queueing}
\label{sec:arch:queue}
Due to restricted resources on the board and desired parallelism between the different components and ports, queueing is an important aspect of the driver and different kinds of queues are introduced.

The first and most important queue is the client-side \textit{write queue}. Such a queue is introduced for each in-going port. Writing to a port does not directly result in a message sent to the board, since the board has restricted resources and may not be able to process or even store the value. The client queue provides a first mechanism of \textit{flow control}. Values are queued up at the client, when the board buffers have been filled and no more values can be received, until the board signals that it can receive more values now.
Additionally, the client buffer offers \textit{congestion avoidance} to a small degree, since several small values can be packaged together in one message. This results in a smaller amount of messages being sent over the medium.

The client also contains \textit{read queues} for each out-going port. These queues cache values received by the board for read operations performed by the application. Values are pushed from the board into theses queues automatically. These queues lead to smaller resource consumption on the board, since only a small number of out-going values have to be cached. Read cycles are faster, since no polling messages have to be sent but available values can directly be consumed. On the downside, client-side read queues lead to some possibly unnecessary traffic on the medium, since values are send without being requested at the board. 

To counter above disadvantage, \textit{polling ports} are introduced. These are special out-going ports, to which data is not actively forwarded. Instead, the port requests values, as soon as a read operation is performed on the port. While this results generally in longer response cycles compared to forwarding ports, the medium traffic is reduced as values are only sent if needed. This is especially useful in a scenario, where a component constantly generates values, for example a random number generator. These ports do not require a read queue on the host. Instead, the number of unserviced polls is stored in a \textit{poll counter} at the board-side port. Note, that this has no effect on the host-side API. Only the response times and memory behaviour of the driver may change.

With only client-queues, the board-side driver would only be capable of receiving and processing a single value at a time, which has to be directly written to a component, resulting in an increase of messages and therefore communication overhead. In order to enable reception of multiple values at once, a \textit{board-side queue} (or \textit{software queue}) is introduced for each in-going port on the board as well. Received values are stored in these queues first and forwarded to the target component later on, if the component can process further values. In contrast to the client-side queues, are size-restricted and can only hold a certain number of values, specified in the board description file.
Similar queues are introduced for out-going ports, to reduce traffic caused by values being sent back to the host-side driver. These queues cache results from components which are then send in one message.

Since the FPGA usually only has a single processor and is not capable of multi-threading, only a single board-side queue can be read at a time, and only a single component can receive values. In order to feed all components with faster with values, a queue is implemented in hardware and placed in between the component and the stream interface of the processor. These \textit{hardware queues} provide the component with values as soon as it requires a new value and therefore remove the idle time between the end of a computation of a component and the board-side driver thread serving the component new values. Since these queues are actually less efficient in terms of resource consumptions on the board than the software queues, they are even smaller in size. Again, similar queues on out-going ports cache results, so the component does not have to wait for the driver thread to read the value from the port before starting the next computation.

\subsection{I/O Threads}
\label{sec:arch:threads}
As stated in \Cref{sec:api:port}, %where else
the driver should support asynchronous writes and reads. The order of messages to the same port has to be maintained, while the order of messages to different ports can be changed. The processing of operations at ports is independent from other ports. In particular, a synchronous operation on a port should not influence an asynchronous operation on another port.\\
Consider the following example to understand why asynchronous operations should still be processed during a synchronous operation. A board specification contains an adder component with two in-going ports and an out-going port. If a values are written at both ports, they will be consumed and a result will be returned at the out-going port. Consider further, that a value is currently stored at port A. The user now writes another value to port A asynchronously, followed by writing three values to port B synchronously. The value for port A cannot be written directly, since port A is still blocked with a value. However, the first value for port B can be written, and both values are consumed. Now the second value for port B can be written, blocking the port for the third value. This third value cannot be written, until the second value is consumed, which requires another value at port A. If write operations are performed asynchronously, the asynchronous write to port A will never reach this port, since the application is still blocked from the write to port B. Allowing asynchronous writes to be processed in parallel resolves this situation. The value for port A can be written in between the writes to port B or at any point afterwards.\\

Asynchronous operations can be realised by dedicated I/O threads, handling communication between host-side and board-side driver. These threads modify the client-side queues described above in \Cref{sec:arch:queue}. In general, a single thread, that covers the complete communication is be sufficient. For better separation between writing and reading operations, two threads can be introduced for, one for each of these operations. This solution if preferable, since reading from the medium usually involves longer periods of listening for messages, which would unnecessarily delay write operations. A third solution, implementing the independence of operations on different ports, is introduction of a single thread for each port. This, however, results in a possibly large number of threads. Depending on the host platform, a smaller number is preferable.

The threads have to be started with a special method \texttt{startup()} before using the API and should be shut down afterwards with another method \texttt{shutdown()}.

\subsection{Bitwidth Translation}
\label{sec:arch:bitwidth}
As described in \Cref{sec:api:port}, ports allow arbitrary bitwidth. As the size of the AXI stream interface directly connected to the FPGAs processor is usually fixed, translation to this fixed size has to occur somewhere in between. Performing this translation on-board consumes limited board resources. Doing the translation on the client however increases communication overhead. Depending on the application, both solutions can make sense.

A board-side translation requires send messages to be augmented with the bit-size of each value. Values can than be padded and/or split, according to the required and the actual bitwidth. This translation is individual for each port.

A client-side translation does not require the bit-size to be transmitted. Padding and translation in this case is done immediately before transmission. This reduces the required memory for client-side queueing compared to direct padding before the client-side queue. Re-translation to the actual bitwidth has to be done directly after the AXI stream interface of the processor.

\section{Protocol}
\label{sec:protocol}
This section covers the transmission protocol between client and server application. 

The protocol is based on the assumptions made above about client and server, specifically the used buffers and client I/O threads allowing parallelism with sending and receiving messages. Furthermore, the underlying medium and protocol are expected to be reliable and order-preserving.

\subsection{Control Flow}
\label{sec:protocol:cfg}

This section describes the state of the driver and summarises messages that are sent during each transition. To simplify the control flow graphs, the following variables and functions are introduced:

\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
  \item \textbf{v} Values of some sort (e.g. an array of integers).
  \item \textbf{a} Memory addresses (e.g. an array of addresses).
  \item \textbf{n} The size of the board-side queue (statically known).
  \item \textbf{i} An unsigned (i.e. positive) integer number, smaller than \texttt{n}.\\

  \item \textbf{size(q)} The number of values currently held by queue \texttt{q}.
  \item \textbf{empty(q)} \texttt{true}, if \texttt{size(q) == 0}, \texttt{false} otherwise.
  \item \textbf{full(q)} \texttt{true}, if the queue is full, \texttt{false} otherwise.
  \item \textbf{store(q,v)} Stores the values \texttt{v} into queue \texttt{q}.
  \item \textbf{take(q)} Returns the first value of a queue \texttt{q}. Removes the value from the queue.
  \item \textbf{drop(q,i)} Drops the first \texttt{i} values of \texttt{q}.
  \item \textbf{peek(q,i)} Obtain the first \texttt{i} values of \texttt{q}. Returns a smaller number of values, if only less are available, i.e., \texttt{size(q)} \textless ~\texttt{i}.
  \item \textbf{asgn(a,v)} Assigns a value \texttt{v} to an address  \texttt{a}.
\end{itemize}

Messages are exchanged between the application and the client-side driver, as well as between client-side and board-side driver. The following messages are the most important ones influencing the state of the driver:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
  \item \textbf{wrt(v)} Request from the application to write values \texttt{v} to the port.
  \item \textbf{read(a)} Request from the application to read values to the addresses \texttt{a}.
  \item \textbf{notify} Notifies the application that all tasks queued up at a port have been processed.
  \item \textbf{data(v)} A data message containing values \texttt{v} for or from a port.
  \item \textbf{ack(i)} Acknowledges successful reception of \texttt{i} values.
  \item \textbf{poll} A request message for additional data.
\end{itemize}

\subsubsection{Host-Side Driver}
Since values can be written asynchronously, each port maintains its own state and can perform transitions independent of the other ports. The state of the host-side driver is constructed from the individual states of all ports.

The state of an in-going port is physically represented by two variables \texttt{q} and \texttt{s}. \texttt{q} denotes the queue, while \texttt{s} stores the number of values in transit, i.e. those, that have been sent but not yet acknowledged. A more abstract view on the state of an in-going port is provided in \Cref{fig:cfg:hostIn}. Each state represents a combination of these variables. Changes to these variables are not explicitly denoted in the diagram.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\coordinate(center);

\node[state] (init) at (0,0) {Init};
\node[above left = 2em and 4em] (anchor) at (init){};
\node[state, below=10em] (write) at (init) {Write};
\node[state, below=10em] (wait) at (write) {Wait};
\node[state, right=12em] (idle) at (wait) {Idle};

\draw[extend, black] (anchor) to node[auto] {} (init);
\draw[arr, black, bend right = 20] (init) to node[midway, left=0.2em] {$\inferrule{wrt(v)}{store(q,v)}$} (write);
\draw[arr, black, bend right = 20] (write) to node[midway, right=0.2em] {$\inferrule{[empty(q)]}{notify()}$} (init);

\draw[arr, black, bend right = 20] (write) to node[midway, left=0.2em] {$\inferrule{[!empty(q)]}{data(peek(q,n))}$} (wait);
\draw[arr, black, bend right = 20] (wait) to node[midway, right=0.2em] {$\inferrule{ack(i) ~ [i == s]}{drop(q,i)}$} (write);

\draw[arr, black] (wait) to node[midway, above=0.2em] {$\inferrule{ack(i) ~ [i < s]}{drop(q,i)}$} (idle);
\draw[arr, black, bend right = 40] (idle) to node[midway, right=1em] {$\inferrule{poll}{}$} (write);

\end{tikzpicture}
\label{fig:cfg:hostIn}
\caption{Host-side control flow graph of an in-going port}
\end{figure}

Several loops have been left out in order to simplify the graph. Messages \texttt{ack} or \texttt{poll} in other states than specified in the graph will simply be ignored. An application write in any state will result in the values to be appended to \texttt{q}.

The state of an out-going port is represented by two variables \texttt{q} and \texttt{r}. \texttt{q} is a queue of memory addresses, where values should be read to, \texttt{r} is a queue of values read from the medium but not from the application so far.

Values are automatically pushed forward from the board and stored in \texttt{r}. If the application requests a \texttt{read}, values are shifted from \texttt{r} into \texttt{q}. The application is notified, once all read requests have been served.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\coordinate(center);

\node[state] (init) at (0,0) {Init};
\node[above left = 2em and 4em] (anchor) at (init){};
\node[state, below=10em] (read) at (init) {Read};
\node[state, right=10em] (idle) at (read) {Idle};

\draw[extend, black] (anchor) to node[auto] {} (init);
\draw[arr, black, out=330, in=30, looseness=6] (init) to node[midway, right=0.2em] {$\inferrule{data(v)}{store(r,v)}$} (init);

\draw[arr, black, bend right = 20] (init) to node[midway, left=0.2em] {$\inferrule{read(a)}{store(q,a)}$} (read);
\draw[arr, black, out=300, in=240, looseness=6] (read) to node[midway, below=0.2em] {$\inferrule{[!empty(q) ~\wedge~ !empty(r)]}{asgn(take(q), take(r))}$} (read);
\draw[arr, black, bend right = 20] (read) to node[midway, right=0.2em] {$\inferrule{[empty(q)]}{notify()}$} (init);

\draw[arr, black, bend left = 20] (read) to node[near end, above=0.2em] {$\inferrule{[empty(r) ~\wedge~ !empty(q)]}{}$} (idle);
\draw[arr, black, out=330, in=30, looseness=6] (idle) to node[midway, right=0.2em] {$\inferrule{read(a)}{store(q,a)}$} (idle);
\draw[arr, black, bend left = 20] (idle) to node[near start, below=0.2em] {$\inferrule{data(v)}{store(r,v)}$} (read);

\end{tikzpicture}
\label{fig:cfg:hostOut}
\caption{Host-side control flow graph of an out-going port}
\end{figure}


\subsubsection{Board-side Driver}
The state of the board-side driver is also represented as concatenation of the states of all ports. The state of a port on the board is represented by the corresponding software queue \texttt{q} and the corresponding hardware queue \texttt{r}.

Since only a single thread can run on the FPGA, a scheduler determines which port can make a step. The default scheduler switches to a different port, once the current port cannot perform any more steps. It is possible for the user to define a more elaborate scheduler, if so desired.

An in-going port, as shown in \Cref{fig:cfg:boardIn}, sends acknowledgements for received data packages and stores received values. If it has received values and can write to the hardware queue at some point, it switches to consuming received messages. Messages are then shifted from the software queue to the hardware queue, until either the hardware queue is filled or the software queue is emptied. If the software queue was full before shifting the first message, a poll is sent in addition. After shifting all values possible, the port switches back to listening for more values. 

\begin{figure}[h]
\centering
\begin{tikzpicture}
\coordinate(center);

\node[state] (listen) at (0,0) {Listen};
\node[above left = 2em and 4em] (anchor) at (listen){};
\node[state, below=10em] (read) at (listen) {Consume};

\draw[extend, black] (anchor) to node[auto] {} (listen);
\draw[arr, black, out=330,in=30,looseness=6] (listen) to node[midway, right=0.5em] {$\inferrule{data(v)}{ack(store(q,v))}$} (listen);
\draw[arr, black, bend right=20] (listen) to node[midway, left=0.2em] {$\inferrule{[!empty(q) ~\wedge~ !full(r)]}{ }$} (read);
\draw[arr, black, bend right=20] (read) to node[midway, right=0.2em] {$\inferrule{ [empty(q) \vee full(r)]}{ }$} (listen);
\draw[arr, black, out=330, in=30, looseness=6] (read) to node[midway, right=0.2em] {$\inferrule{[full(q) ~ \wedge ~ !full(r)]}{store(r, take(q)) ~~ poll}$} (read);
\draw[arr, black, out=210, in=150, looseness=6] (read) to node[midway, left=0.2em] {$\inferrule{[!full(q) ~ \wedge ~ !empty(q) ~\wedge~ !full(r)]}{store(r,take(q))}$} (read);
\end{tikzpicture}
\label{fig:cfg:boardIn}
\caption{Board-side control flow graph of an in-going port}
\end{figure}

\newpage
The out-going port is even simpler (see \Cref{fig:cfg:boardOut}). It shifts values from the hardware queue to the software queue as long as possible. Then it sends a data message with all values contained in the software queue.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\coordinate(center);

\node[state] (listen) at (0,0) {Init};
\node[above left = 2em and 4em] (anchor) at (listen){};

\draw[extend, black] (anchor) to node[auto] {} (listen);
\draw[arr, black, out=330, in=30, looseness=6] (listen) to node[midway, right=0.2em] {$\inferrule{[!empty(r) ~\wedge ~ !full(q)]}{store(q,take(r))}$} (listen);
\draw[arr, black, out=240, in=300, looseness=6] (listen) to node[near end, right=0.5em] {$\inferrule{[full(q) \vee empty(r)]}{data(take(q,n))}$} (listen);
\end{tikzpicture}
\label{fig:cfg:boardOut}
\caption{Board-side control flow graph of an out-going port}
\end{figure}

A polling port is slightly more complex, since it can only send, it values are requested. Once a poll arrives, the ports poll counter \texttt{s} is incremented by the number of requested values. If the poll counter is greater than zero, the port may start sending values. The port is only allowed to send as many messages as requested, but is also restricted by the software queue size \texttt{n}. Consequently, it can only send \texttt{max(s,n)} values per step.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\coordinate(center);

\node[state] (idle) at (0,0) {Idle};

\node[above left = 2em and 4em] (anchor) at (idle){};
\draw[extend, black] (anchor) to node[auto] {} (idle);

\draw[arr, black, out=330, in=30, looseness=6] (idle) to node[midway, right=0.2em] {$\inferrule{poll(i)}{s~+=~i}$} (idle);

\node[state, below = 6em] (send) at (idle) {Send};
\draw[arr, black, bend right=20] (idle) to node[midway, left=0.2em] {$\inferrule{[s > 0]}{ }$} (send);
\draw[arr, black, bend right=20] (send) to node[midway, right=0.2em] {$\inferrule{[s == 0]}{ }$} (idle);

\draw[arr, black, out=330, in=30, looseness=6] (send) to node[midway, right=0.2em] {$\inferrule{poll(i)}{s~+=~i}$} (send);
\draw[arr, black, out=210, in=150, looseness=6] (send) to node[midway, left=0.2em] {$\inferrule{[i > 0]}{data(take(q,max(i,n)))}$} (send);

%\draw[arr, black, out=330, in=30, looseness=6] (listen) to node[midway, right=0.2em] {$\inferrule{[!empty(r) ~\wedge ~ !full(q)]}{store(q,take(r))}$} (listen);
%\draw[arr, black, out=240, in=300, looseness=6] (listen) to node[near end, right=0.5em] {$\inferrule{[full(q) \vee empty(r)]}{data(take(q,n))}$} (listen);
\end{tikzpicture}
\label{fig:cfg:boardOut}
\caption{Board-side control flow graph of an out-going port}
\end{figure}

\subsection{Message Encoding}
\label{sec:protocol:encode}
This section covers the translation of the above messages into messages on the communication medium. Messages can be split into header and payload. The header describes the payload to follow, the payload contains a number of 32-bit values that are sent to or form a component.

The first 8 bit of the header are reserved for the \textit{protocol version}, the message was encoded with. The only version currently available is version 1.

\paragraph{Procotol Version 1}

This version reserves the next 4 bit of the header for the \textit{type} field, which  determines which kind of message is represented. Depending on the type, the 4-bit \textit{ID} field is used as identifier for either ports, gpio components or error types. Finally, the 16-bit field \textit{size} marks either the size of the payload in 32-bit values, or, for messages with only small data content, is used directly to store the data without utilizing the payload field, i.e. a payload size of 0. This leads to messages, that generally look as depicted in \Cref{fig:proto:bitorder}. \\

\begin{figure}[h]
\centering
\begin{bytefield}{32}
  \bitheader{0,7,11,15,31} \\
  \bitbox{8}{Version} & \bitbox{4}{Type} & \bitbox{4}{ID} & \bitbox{16}{Size} \\
  \wordbox{3}{Payload}
\end{bytefield}
\caption{Bitorder of the message on the medium}
\label{fig:proto:bitorder}
\end{figure}

Values in this protocol version are expected to be properly aligned with 32-bit, meaning that, as described in \Cref{sec:arch:bitwidth}, values are padded host-side to a multiple of 32-bit and then split into 32-bit blocks.
Note, that due to the size being only a 16-bit field, only $2^{16}-1$ such values can be written or read with a single message. The API has no such restriction and host-side queues are not bound by any size constraint either. This admittedly unlikely scenario has to be treated in the I/O thread, by splitting tasks accordingly.

The control flow graphs in \Cref{sec:protocol:cfg} specify what types of messages are required. A short overview of the messages together with their type encoding and their fields is provided in \Cref{tab:proto:messages}. The following paragraphs provide a more detailed description of the message and their meaning.

\begin{table}[h]
\centering
\begin{tabular}{ c | c | c | c | c } 
Message & Type & ID & Size & Payload\\ \hline
Data & 1001 & Port ID & Payload Size & Yes\\
GPIO & 1110 & GPIO ID & GPIO State & No\\
Ack & 1111 & Port ID & Ack Count & No\\
Poll & 1010 & Port ID & Poll Count & No\\
Reset & 0000 & Unused & Unused & No\\
Debug & 0111 & Debug Type & Payload Size & Yes
 \end{tabular}
\caption{Overview of messages in protocol version 1}
\label{tab:proto:messages}
\end{table}

\paragraph{Data Message}
A data message marks either a set of values for a specific component being sent from the host to the board or a set of values from a specific component being sent from the board to the host. As such, it requires an identifier for the target or source component as well as the size of the contained payload in words (i.e. 32-bit values). 
Values sent with a data message are expected to always be full 32-bit values.

The direction the data message is sent in, determines if it is addressed at an in-going or out-going port. Data messages from the host are directed at in-going ports, data messages from the board are directed at out-going ports. Consequently, 16 in-going and 16 out-going ports can be addressed using a 4-bit ID field.

\paragraph{Acknowledgement}
The acknowledgement confirms reception of a number of values by a specific component. For this purpose, no payload is required. Instead, the number of acknowledged values is encoded within the \textit{size} field.

\paragraph{Data Request (Poll)}
A data request is used to inform the host, that additional values can now be received. This is necessary if the queue was full beforehand, i.e. a partial acknowledgement was (most likely) sent. This poll does require neither a payload nor a size, but only the identifier of the component, that can now receive values.

The data request is also used at polling ports. Here, it notifies the board, the the host requires values from the port. The Size field is used to specify how many values are requested.

As with data messages, the direction of the poll message determines if an in-going or out-going port is addressed. However, the translation is inverse to the data message. A poll from the host is addressed at an out-going port, a poll from the board at an in-going port.

\paragraph{GPIO Message}
A GPIO message is a special type of data message, addressed to a GPIO component. GPIO components use their own address space, disjunct from the addresses used by "normal" components. They are not connected via AXI Stream interfaces but direct memory addresses, consequently they do not influence any port restrictions.

Furthermore, GPIO components do only store their current state and perform no calculation like VHDL components. The state is represented by an 8 bit value and is encoded directly in the size field instead of the payload. Storing only the current state also means, that no queues exist for GPIO components and no acknowledgements are required. The new state is simply written into (or read from) memory

\paragraph{Reset Message}
This message is not specified in the protocol above. A reset message sent by the host-side driver resets the state of the board-side driver, clearing all queues and setting the reset flag for all components. The board-side driver acknowledges a successful reset by answering with a reset message. 
The target and size fields are unused by the reset message.

\paragraph{Debug Message}
This message also is not specified in the protocol. It marks a notification of some sort, sent by the board. This can be debug output of the driver running on the board, a warning message about skipped messages or an unhandled error, that occurred on the board. For these messages, the payload contains a string.
The target bits are used to differentiate between the debug message type. The bit encoding is shown in \Cref{tab:protoDebug}. Values in between have been left unused for future use (e.g. finer grained warnings or info messages).

\begin{table}[h]
\centering
\begin{tabular}{ c | c } 
Severity & Encoding \\ \hline
Info & 0011 \\
Warning & 1000 \\
Error &  1101 \\
 \end{tabular}
\caption{Debug message encoding}
\label{tab:protoDebug}
\end{table}

While it is possible to provide debug output over the JTag cable, the FPGA is programmed with, this quickly slows down computation with larger debug outputs. Using the Ethernet connection also for debug output vastly accelerates such computations.

\subsection{Sequence charts}
\label{sec:protocol:sequence}

The following sequence charts describe typical interaction patterns and offer a different view than the control flow graphs in \Cref{sec:protocol:cfg}. They use the same methods and messages as declared earlier, but may introduce additional ones. The intended functionality of these methods should be obvious from the name and parameters.,

%write first & more
\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40, node distance = 12em]
  \newthread{app}{Application}
  \newinst[1]{port}{Port}
  \newinst{tq}{Task Queue}
  \newthread[1]{io}{I/O Handler}

\begin{sdblock}{Write}{}
  \begin{call}{app}{nbwrite(v)}{port}{write* w}
    \begin{callself}{port}{createTask(v)}{write* w}
    \end{callself}
    \postlevel
    \begin{call}{port}{put(w)}{tq}{}
    \end{call}
    \mess{port}{notify()}{io}
  \end{call}
\end{sdblock}
\end{sequencediagram}

\caption{An application writing values through the host-side driver api}
\label{fig:seq:host:write}
\end{figure}

The host-side view on a write operation is depicted in \Cref{fig:seq:host:write}. An application writes values to a port. The port stores the written values to its local queue and notifies the I/O thread, that new values are available to be written. This notification may get ignored, if the I/O handler isn't waiting for a notification, but is still busy processing. In this case, the values will be written, whenever the corresponding port is reached by the thread. 

In case of a non-blocking write operation as in \Cref{fig:seq:host:write}, the write operation returns after this notification and the application an continue. In case of a blocking write operation, the port starts waiting for a notification after notifying the I/O handler. This notification will be sent after all values got acknowledged (compare to \Cref{fig:seq:host:ack}).

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{cq}{Task Queue}
  \newthread[1]{io}{I/O Handler}
  \newinst[1]{m}{Medium}

\begin{sdblock}{Send}{}
  \begin{callself}{io}{schedule(pid)}{}
    \begin{sdblock}{alt}{[!q.empty()]}
      \begin{call}{io}{take(n)}{cq}{v}
      \end{call}
      \begin{call}{io}{data(pid,v)}{m}{}
      \end{call}
    \end{sdblock}
  \end{callself}
\end{sdblock}
\end{sequencediagram}

\caption{A host sending data over the medium}
\label{fig:seq:host:send}
\end{figure}

The I/O handler iterates over all ports. There, it checks if the port is ready to send values. That implies, that values have to be available, there are no unacknowledged values in transit, and the port is not blocked. If this is the case, the I/O handler puts a data package on the medium. This process is depicted in \Cref{fig:seq:host:send}.

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{port}{Port}
  \newinst{cq}{Task Queue}
  \newthread[1]{io}{I/O Handler}
  \newinst[1]{m}{Medium}

\begin{sdblock}{Receive ACK}{}
 \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{ack(pid,i)}
    \end{call}
    \begin{call}{io}{update(i)}{cq}{}
    \end{call}
    \postlevel\postlevel\postlevel\postlevel
  \end{callself}
  \prelevel\prelevel\prelevel\prelevel\prelevel
  \begin{sdblock}{alt}{[q.empty()]}
    \mess{io}{notify()}{port}
  \end{sdblock}
  \postlevel
\end{sdblock}
\end{sequencediagram}
\caption{The host-side driver receiving an acknowledgement from the server}
\label{fig:seq:host:ack}
\end{figure}

After sending a data message, the I/O handler continues its iteration. It also listens for incoming messages. One of these is the acknowledgement, which indicates board-side reception of sent data messages. Receiving an acknowledgement leads to update of the port queue (see \Cref{fig:seq:host:ack}). If the port queue is empty afterwards, the port is notified of this. If a blocking write operation was stalled at the port, it can now return and the application can continue its computations.

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{cq}{Task Queue}
  \newthread[1]{io}{I/O Handler}
  \newinst[1]{m}{Medium}
\begin{sdblock}{Receive Poll}{}
  \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{poll(pid)}
    \end{call}
    \begin{sdblock}{alt}{[p.transit \textless ~ 0]}
      \begin{call}{io}{reset()}{cq}{(v)}
      \end{call}
    \end{sdblock}
  \end{callself}
\end{sdblock}
\end{sequencediagram}
\caption{The host-side driver receiving a data request from the server}
\label{fig:seq:host:poll}
\end{figure}

Another message that can be received by the I/O handler is a poll for additional data, depicted in \Cref{fig:seq:host:poll}. This request is answered with re-setting the polled ports transit counter, if the port is stalled. As a result, the data will be sent from the polled port at the next iteration, or as soon as available. If the port was not stalled, the poll will be ignored. This implies, there is either data already in transit (i.e., will arrive after the poll was sent - which is exactly what the poll is supposed to achieve) or there is no data to send despite the port not being blocked (in which case data will be sent as soon as available even without the poll).

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{m}{Medium}
  \newthread[1]{ser}{Board}
  \newinst[1]{sq}{SW Queue}
 \begin{sdblock}{Board Read}{}
  \begin{callself}{ser}{schedule(read)}{}
    \begin{call}{ser}{recv()}{m}{data(pid,v)}
    \end{call}
    \begin{call}{ser}{store(v)}{sq}{i}
    \end{call}
    \begin{call}{ser}{ack(pid,i)}{m}{}
    \end{call}
  \end{callself}
\end{sdblock}
\end{sequencediagram}
\caption{The board-side driver receiving a data package from the client}
\label{fig:seq:board:read}
\end{figure}

On the board, a single thread is running. This thread, similar to the host-side I/O thread, listens to incoming messages. Receiving a data message results in the message being stored at the software queue and values being acknowledged (cf. \Cref{fig:seq:board:read}). At a later point, values will be shifted from the software queue to the hardware queue without further involvement of the host.

%Composition example
\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{app}{Application}
  \newinst{port}{Port}
  \newinst{tq}{Task Queue}
  \newthread{io}{I/O Handler}
  \newinst{m}{Medium}
  \newthread{ser}{Board}
  \newinst{sq}{SW Queue}
\begin{sdblock}{Non-Blocking Write}{}
\node at (app) {};
\node at (port) {};
\node at (tq) {};
\end{sdblock}
\begin{sdblock}{Send}{}
\node at (tq) {};
\node at (io) {};
\node at (m) {};
\end{sdblock}
\begin{sdblock}{Board Read}{}
\node at (m) {};
\node at (ser) {};
\node at (sq) {};
\end{sdblock}
\begin{sdblock}{Receive ACK}{}
\node at (port) {};
\node at (tq) {};
\node at (io) {};
\node at (m) {};
\end{sdblock}
\end{sequencediagram}
\caption{Composed example of a non-blocking write using the building blocks defined before.}
\label{fig:seq:comp1}
\end{figure}

A composition of these smaller building blocks is depicted by \Cref{fig:seq:comp1}. This example shows the complete effects of a non-blocking write initiated by the application. First of all, the non-blocking write is handled host-side resulting in the values being stored in the port queue. Once the I/O thread reaches this port, the values are sent over the medium. The board receives the values, stores them in the software queue and sends an acknowledgement. The acknowledgement is in turn received by the I/O handler again which updates the port queue updating the write task and removing it from the queue.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Following are the complete use-cases... (which take about a page each)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{app}{Application}
  \newinst{cl}{Port}
  \newinst{cq}{Task Queue}
  \newthread{io}{I/O Handler}
  \newinst{m}{Medium}
  \newthread{ser}{Board}
  \newinst{sq}{SW Queue}
  
\begin{sdblock}{Non-Blocking Write}{}
  \begin{call}{app}{nbwrite(v)}{cl}{write* w}
    \begin{callself}{cl}{createTask(v)}{write* w}
    \end{callself}
    \begin{call}{cl}{put(w)}{cq}{}
    \end{call}
  \end{call}

  \prelevel\prelevel
  \begin{callself}{io}{schedule(pid)}{}
    \begin{call}{io}{take(n)}{cq}{v}
    \end{call}
    \begin{call}{io}{data(pid,v)}{m}{}
    \end{call}
  \end{callself}

  \prelevel\prelevel
  \begin{callself}{ser}{schedule(read)}{}
    \begin{call}{ser}{recv()}{m}{data(pid,v)}
    \end{call}
    \begin{call}{ser}{store(pid,v)}{sq}{s(v)}
    \end{call}
    \begin{call}{ser}{ack(pid,s(v))}{m}{} % this is only the server-side ack, not the component ack!! for component ack, it has to be out of the mb queue!
    \end{call}
  \end{callself}

  \prelevel
  \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{ack(pid,s(v))}
    \end{call}
    \begin{call}{io}{update(s(v))}{cq}{}
    \end{call}
  \end{callself}
\end{sdblock}

\end{sequencediagram}
\caption{A sequence diagram for a non-blocking write. Note, that non-blocking only means, the host does not wait for the target \textbf{component} to receive the message, but still waits for the client host to receive the values.}
\label{fig:seq:nbwrite}
\end{figure}

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{app}{Application}
  \newinst{cl}{Host}
  \newinst{cq}{Task Queue}
  \newthread{io}{I/O Handler}
  \newinst{m}{Medium}
  \newthread{ser}{Board}
  \newinst{sq}{SW Queue}
  
\begin{sdblock}{Blocking Write}{}
  \begin{call}{app}{write(v)}{cl}{}
    \begin{callself}{cl}{createTask(v)}{write *w}
    \end{callself}
    \postlevel
    \begin{call}{cl}{put(w)}{cq}{ }
% problem with this call over the first version: this doesn't directly inform the I/O Handler of NEW data for a component
% instead, when the handler schedules a component, he doesn't know if he should send data or wait for a poll.
% we COULD solve this with an additional boolean flag on client side.
% I'm not convinced, that the first version can be implemented, since it would basically circumvent the scheduler.
% alternative: remove the component from the list of components to schedule, if we wait for a poll or ack. This is handled in the recv phase of the scheduler
    \end{call}
    \begin{callself}{cl}{wait()}{}
    \postlevel\postlevel\postlevel\postlevel\postlevel\postlevel
    \postlevel\postlevel\postlevel\postlevel\postlevel\postlevel
    \postlevel\postlevel\postlevel\postlevel
    \end{callself}

    \prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel
    \prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel
    \prelevel\prelevel\prelevel

    \begin{callself}{io}{schedule(pid)}{}
      \begin{call}{io}{take(n)}{cq}{v}
      \end{call}
      \begin{call}{io}{data(pid,v)}{m}{}
      \end{call}
    \end{callself}

    \prelevel\prelevel
    \begin{callself}{ser}{schedule(read)}{}
      \begin{call}{ser}{recv()}{m}{data(pid,v)}
      \end{call}
      \begin{call}{ser}{store(v)}{sq}{s(v)}
      \end{call}
      \begin{call}{ser}{ack(a,s(v))}{m}{} % this is only the server-side ack, not the component ack!! for component ack, it has to be out of the mb queue!
      \end{call}
    \end{callself}

    \prelevel
    \begin{callself}{io}{schedule(read)}{}
      \postlevel
      \begin{call}{io}{recv()}{m}{ack(pid,s(v))}
      \end{call}
      \begin{call}{io}{update(s(v))}{cq}{}
      \end{call}
    \mess{io}{notify()}{cl}
    \end{callself}
  \prelevel
  \end{call}

\end{sdblock}

\end{sequencediagram}
\caption{A sequence diagram for a blocking write. Note, that only the application is blocked, not the I/O handler, which may process non-blocking writes sent before the blocking write \textbf{after} the non-blocking write.}
\label{fig:seq:bwrite}
\end{figure}


\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{cq}{Task Queue}
  \newthread{io}{I/O Handler}
  \newinst{m}{Medium}
  \newthread{ser}{Board}
  \newinst{sq}{SW Queue}

\begin{sdblock}{Polling}{}

  \begin{callself}{ser}{schedule(a)}{}
    \postlevel
    \begin{call}{ser}{hasSpace(a)}{sq}{true}
    \end{call}
    \begin{call}{ser}{poll(a)}{m}{}
    \end{call}
  \end{callself}

  \prelevel
  \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{(poll, a)}
    \end{call}
    \begin{call}{io}{getValues(a)}{cq}{(v)}
    \end{call}
    \begin{call}{io}{send(a,v)}{m}{}
    \end{call}
  \end{callself}

  \prelevel\prelevel
  \begin{callself}{ser}{schedule(read)}{}
    \begin{call}{ser}{recv()}{m}{(a,v)}
    \end{call}
    \begin{call}{ser}{store(a,v)}{sq}{}
    \end{call}
    \begin{call}{ser}{ack(a,v)}{m}{}
    \end{call}
  \end{callself}

    \prelevel
    \begin{callself}{io}{schedule(read)}{}
      \postlevel
      \begin{call}{io}{recv()}{m}{(ack,a,s(v))}
      \end{call}
      \begin{call}{io}{remove(a,s(v))}{cq}{}
      \end{call}
    \end{callself}

\end{sdblock}

\end{sequencediagram}
\caption{A polling scenario. The server scheduler reaches component a and registers free space in the queue (that was formerly full). He then polls values for component a. The poll triggers sending of data at the client, which is later received in a read phase of the server.}
\label{fig:seq:poll}
\end{figure}



\section{Current Driver Implementations}
\label{sec:impl}
The current implementations include a \texttt{C++} host-side driver and a board-side driver for the Virtex-6 ML605 board. These implementations are described in detail here, giving driver developers an idea, how an implementation of this architecture can look like. 

%Currently, three of these components are supported:
%\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
%\item LEDs
%\item Switches
%\item Buttons
%\end{itemize}

\subsection{C++ Host-Side Driver}
\label{sec:impl:cpp}
The following sections will highlight selected, important aspects of the \texttt{C++} implementation of the host-side driver.

\subsubsection{Structure}
The host side driver is structured roughly into three groups of files and classes, located in different folders. The folder \textit{api} contains everything, the application should have access to, i.e., components and ports. The folder \textit{io} contains files handling communication between host-side driver and the medium. These files are not required directly by an application. The third group of files contains utility classes used by both io and api. These files are simply located in the root folder of the driver.

The api files used by the application have been described in some detail in \Cref{sec:api} already. A detailed description of methods generated for writing and reading values can be found in the api specification of a generated driver. It is advisable, to provide these operations for single values and for groups of multiple values. How these values are grouped, depends on the language. The \texttt{C++} implementation provides these operations for arrays (together with a size parameter) and \texttt{std::vectors} of values.

\subsubsection{I/O Handler}
The driver implements two separate threads for write and read operations, which has been presented as preferred solution in \Cref{sec:arch:threads}.
The reading thread utilizes the \texttt{select} method defined in TCP, which waits for incoming messages without consuming CPU resources. The writing thread iterates over all in-going ports, until an iteration writes no values. If this happens, it starts waiting for new data, an acknowledgement or a poll.

\subsubsection{Communication medium}
The communication medium is part of the I/O handler of the driver and wraps lower-level communication (essentially transport layer and below) between host and board driver. The communication medium abstracts from the actually used technology and provides a homogeneous api for the I/O threads. Network interface specific initialisation is generated as well and is not required by the user (other than annotating configuration details in the board description).

Currently, three communication mediums are envisioned:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{Ethernet Lite}, which is already implemented
\item \textbf{USB/UART}, which is considered as second interface and
\item \textbf{PCI Express}, which is not implemented in the initial driver generator.
\end{itemize}

\paragraph{Ethernet Lite}
Communication over Ethernet is based on the lightweight IP stack, originally developed by Adam Dunkels\footnote{The lwip stack is documented with a wiki available at \url{http://lwip.wikia.com/wiki/LwIP_Wiki}}.

It is possible to implement more efficient Ethernet communication using dedicated VHDL components instead of running the lwip stack on the general purpose CPU. Such a component could easily be integrated in form of a new Communication Interface. An example for a dedicated VHDL communication component together with a client API is described in \cite{alachiotis10, alachiotis12}.

\textcolor{red}{Describe implementation of general interface methods in Ethernet as well as challenges and problems this interface poses.}

\paragraph{USB/UART}
While communication over USB/UART is rather slow, it provides a more simple method of communication than using Ethernet. 

\paragraph{PCI Express}
\textcolor{red}{According to \cite{alachiotis10}, there exists a Xilinx wrapper for PCIE communication.}


\subsection{Virtex 6 ML 605 Board-Side Driver}
The following sections will highlight selected, important aspects of the implementation of the Virtex-6 ML605 board-side driver.

\subsubsection{Structure}
The board-side driver is structured similarly to the host-side driver. There are three groups of files, located in dedicated folders. 

The first group, files handling communication over the medium - is located in the \textit{medium} folder. The content of this folder varies, depending on the medium, the board should be attached to. Medium-specific setup and communication is handled here. A contained folder \textit{protocol} includes files for protocol encoding and decoding (independent from the attached medium). An incoming messages is passed to the protocol decoder and subsequently delegated according to its header.

A second folder \textit{components} contains files concerning hardware components of the board and communication with these components. This includes VHDL components attached with AXI stream interfaces as well as GPIO components or the interrupt controller of the board.

The third group of files contains utility functions and structures, used by both other groups. These files are located directly in the root folder.  This includes software queues and the setup required for these.

The main method for the board-side driver thread is located in the \texttt{main.c}. It calls initialisation procedures of the medium and all components and starts the scheduling loop.

\subsubsection{Scheduler}
The default scheduling loop performs the following operations:

First, it checks for incoming messages and process their contents. Most of the time, this includes storing values in the in-going microblaze queue and acknowledging them. More details about message handling can be found in \Cref{sec:protocol}.

The loop also shifts messages from in-going microblaze queues to in-going hardware queues and vice versa from out-going hardware queues to the out-going microblaze queue. Finally, once the out-going queue is filled or no more values are available, it warps values into a message and write this message to the medium. 

The loop can be overridden by the user, but is required to perform all these operations at some point for the driver to work correctly.

\subsubsection{Restrictions}
This section covers restrictions of the Virtex 6 board and (if available) implemented workarounds.

\paragraph{Port Count}
The microblaze on the Virtex 6 only allows 16 AXI master interfaces and 16 AXI slave interfaces. As a result, only 16 in- and out-going ports can be specified when generating a Virtex 6 board driver. Circumventing this restriction is possible by implementation of a multiplexer which delegates values to one of several components, but this is left to the user.

\paragraph{Bitwidth Translation}
As explained in \Cref{sec:arch} and \Cref{sec:protocol}, transmitted values are padded to a multiple of 32-bit for transmission and have to be re-translated at the board-side driver.
Since AXI stream ports of the microblaze processor on the Virtex 6 (as well as the ARM) are fixed at 32-bit, this translation has to occur \textbf{after} the software part of the board-side driver. Consequently, a bit-translator component is put in-between the hardware queues on the board and the interface to the microblaze. This translator is omitted, if the values expected by the attached component are indeed 32-bit values, in order to save some board resources.


\chapter{Generator}
This chapter is used to explain the code generator itself. This information is intended for future developers of the driver generator. \textcolor{red}{A reference to the third Katja report might be useful.}

\section{Used Libraries}
This section gives a short overview over the used libraries and explains what for and why they are used. These libraries are included in the repository and build jar file and require no further user interaction. Still, as the generator code depends on them, they are introduced here for future developers.

\subsection{JFlex \& CUP}
\textcolor{red}{This can be kept short with a reference to the JFlex/Cup documentation}
Flex is a scanner generator, CUP a parser generator. Both together are currently used to parse \texttt{.mhs} files into abstract syntax trees. \textcolor{red}{In future versions, they will be used to parse the DSL of the driver generator.}

\subsection{Katja}
The driver generator uses the Katja tool, developed by the Software Technology Group of the University of Kaiserslautern. This tool generates several data types\footnote{Since these data types will be described using their Katja specifications, it is strongly recommended to read through the Katja specification provided in form of three technical reports at \url{https://softech.informatik.uni-kl.de/Homepage/Katja}}. To be more specific, it provides the AST build up by the CUP parser as well as a model of the \texttt{C/C++} language described in detail in \Cref{sec:cmodel}.

\section{Generation Process}
\label{sec:genprocess}
The overall process of the driver generator is described by \Cref{fig:genprocess}. The source \texttt{.mhs} file describing the system board design is first translated into an internal representation of the board, i.e. an abstract syntax tree. This AST is used as input for the generator, which in turn outputs models of all required header- and source files. These models are translated into files by the \texttt{C/C++} unparser.

Several backends exist to create different types of models. Host backends generate models for source code running on a host machine, board backends generate models for source code running on a board respectively. These backends implement a \texttt{Visitor}, which visits all components of the board, and manipulate the source model accordingly.
Currently, the only available backends are the C++ host backend and the Virtex 6 ML 605 board backend.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);
\node[tool] (gen) at (0,0) {Generator};

\node[file, above=1cm] (ast) at (gen) {Board AST};
\node[tool, above=1cm] (parser) at (ast) {Scanner/Parser};
\node[file, above=1cm] (mhs) at (parser) {.mhs file};

%TODO there is probably a better way to draw this with tikz - but there always is a better way ;)
\node[file, below left = 1.5cm and 0cm of gen] (board3) {};
\node[file, above right = -2.8em and -9em of board3] (board2) {};
\node[file, above right = -2.8em and -9em of board2] (board1) {board files};

\node[file, below right = 1.5cm and 0cm of gen] (host3) {};
\node[file, above right = -2.8em and -9em of host3] (host2) {};
\node[file, above right = -2.8em and -9em of host2] (host1) {host files};

\node[group, fit=(board1) (board2) (board3), label={95:board side}] (board) {};
\node[group, fit=(host1) (host2) (host3), label={75:host side}] (host) {};

\draw[arr] (mhs) to node[auto] {input} (parser);
\draw[arr] (parser) to node[auto] {generates} (ast);
\draw[arr] (ast) to node[auto] {input} (gen);
\draw[arr] (gen) to node[left] {generates} (board);
\draw[arr] (gen) to node[right] {generates} (host);

\draw[arr, <->] (board) to node[below] {communicate} (host);
\end{tikzpicture}
\caption{A rough sketch of the translation process so far}
\label{fig:genprocess}
\end{figure}

\section{CModel}
\label{sec:cmodel}
%TODO completely outdated, but don't want to update this part before all changes are finalised...
The \texttt{C} model provides data types representing a \texttt{C/C++} program. Note, that the model is neither complete nor always valid, i.e. not all \texttt{C} programs can be described using this model and it is possible to specify a model not translating into valid \texttt{C}. Still, the model simplifies the process of code generation. The model is used for generating \texttt{C} as well as \texttt{C++} code.

\begin{lstlisting}[language=java, breaklines=true]
MFile ( MDocumentation doc, String name, MDefinitions defs, MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses classes )

MClass ( MDocumentation doc, MModifiers modifiers, String name, MTypes extend, MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses nested )

MModifier = PRIVATE() | PUBLIC() | CONSTANT() | STATIC() | INLINE()
\end{lstlisting}

First of all, files can be documented using an \texttt{MDocumentation} element. If the documentation is not empty, a \texttt{@file} tag is attached to indicate this as a file documentation for doxygen.  A file has a name and consists of several definitions, structures, enums, attributes and methods. Files also can contain several classes. These classes again have a name and can contain all these components including other classes. In addition, classes can contain modifiers and inherit components from other classes. Classes also can be documented.
The allowed modifiers are private, public, constant, static, and inline. Note, that not all of these modifiers are class modifiers, and several combinations of modifiers are invalid (e.g. private and public). The model relies on the developer to choose modifiers according to the modified program part.

\begin{lstlisting}[language=java, breaklines=true]
MDefinition ( MDocumentation doc, String name, String value)
MStruct ( MDocumentation doc, MModifiers modifiers, String name, MAttributes attributes )
MEnum   ( MDocumentation doc, MModifiers modifiers, String name, Strings values )
\end{lstlisting}

Definitions, structs and enums mark rather trivial tuple productions. A definition simply assigns a name to a value. %something about structs
Enums list a number of possible values. All three can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MAttribute ( MDocumentation doc, MModifiers modifiers, MAnyType type, String name, MCodeFragment initial )
MCodeFragment ( String part, MIncludes needed )
\end{lstlisting}

Attributes are similar to definitions, but are typed and may also be left unassigned, using an empty code fragment. The \texttt{MIncludes} is required if the type of the attribute is not defined within this c file itself. They also can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MMethod ( MDocumentation doc, MModifiers modifiers, MReturnType returnType, String name, MParameters parameter, MCode body )

MReturnType = MAnyType | MVoid() | MNone()

MParameter ( MParamType refType, MAnyType type, String name )
MParamType  = VALUE() | REFERENCE() | CONSTREF()

MCode ( Strings lines, MIncludes needed )
\end{lstlisting}

Methods have a return type and a list of parameters. The method body is also more complex than a simple code fragment and can consist of several lines, which are not checked any further in this model. The return type can be any \texttt{C} type as well as void. For constructors in \texttt{C++}, the return type \texttt{MNone} is used. Parameters also have a type and name. Furthermore, the mode of parameter passing has to be specified.

\begin{lstlisting}[language=java, breaklines=true]
MAnyType = MType             ( String name )
         | MArrayType        ( MAnyType type, Integer length )
         | MPointerType      ( MAnyType type )
         | MConstPointerType ( MAnyType type )
\end{lstlisting}

The type system of the model supports arrays as well as (const) pointers. The basic type is the \texttt{MType}, which consists only of a string that has to reference an existing \texttt{C} type, e.g. \texttt{int}, \texttt{struct student} or \texttt{enum day}. This type can then be extended using pointer or array types. So \texttt{MArrayType(MType("int"), 5)} would mark an integer array of length 5. Note, that these types are nested semantically rather than in the same order as in \texttt{C}. Consequently, a point type of a const pointer type of type integer will be translated into \texttt{int const ** a}.

\begin{lstlisting}[language=java, breaklines=true]
MDocumentation ( Strings doc, MTags tags )

MTag = PARAM      ( String name, Strings details )
     | RETURN     ( Strings details )
     | THROWS     ( String type, Strings details )
     | DEPRECATED ( Strings details ) 
     | SEE        ( String see )
     | AUTHOR     ( String name )
     | SINCE      ( String date )
\end{lstlisting}

For generation of the API, Javadoc style documentation has to be added to the model. A \texttt{MDocumentation} element contains documentation for the following block as well as possibly several tags. Tags can be parameter or return value descriptions of a method/procedure, descriptions for exception behaviour, deprecation descriptions or references to other elements of the code. The \texttt{JAVADOC\_AUTOBRIEF} option is set in the generated doxygen config files, resulting in the first sentence (concluded by a dot and following space or newline) will be used as short description for the documented program part. Since neither the driver generator nor doxygen perform sanity checks, we rely on the user to only introduce meaningful tags for a documentation element. Note further, that the order of tags influences the order of elements in the generated API description.

\section{Unparser}
Different unparsers are used, to translate the \texttt{C} model in actual code. For each instance of the model, a header file and a corresponding source file, either \texttt{C} or \texttt{C++}, has to be generated. These unparsers are called depending on the particular instance of the model. Files intended to be loaded to the board have to be plain \texttt{C}, files intended for the client side can also be \texttt{C++} files. The unparsing itself is realized using the visitor pattern. Each visit method appends code to a string buffer depending on the visited element.

\paragraph{Header Unparser}
The header unparser is used for both, unparsing \texttt{C} as well as \texttt{C++} code. Consequently, it doesn't filter any constructs, but accepts everything specifiable with the model.

This unparser generates only signatures for all methods and only the declarations of attributes and enums. However, the header file will contain all includes referenced within the model.

\paragraph{Plain \texttt{C} Unparser}
Since plain \texttt{C} doesn't have any concept of classes, using a model with classes in this unparser will result in exceptions. Otherwise, all components and combinations are accepted. The source file will only import the corresponding header file, no other headers or sourcefiles.

\paragraph{\texttt{C++} Unparser}
For the \texttt{C++} unparser, like with the header unparser, every component and combination is allowed. The source file will only import the corresponding header file, no other headers or sourcefiles.

\addtocontents{toc}{\protect\vspace*{\fill}}

\newpage
\pagestyle{empty}
\bibliography{bib}
\bibliographystyle{splncs03}
\end{document}