\documentclass{report}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english,german]{babel}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
\usepackage[nameinlink]{cleveref}
%\usepackage{alltt}
%\usepackage{multirow}
%\usepackage{rotating}
\usepackage{listings}
\usepackage{setspace}
\usepackage{mathpartir}

%\usepackage{fancyhdr}
%\setlength{\headheight}{15.2pt}

\usepackage[%gray,
      dvipsnames,svgnames]{xcolor}
\definecolor{light-green}{rgb}{0.9,1,0.85}


\usepackage{tikz}
\usetikzlibrary{shapes,matrix,arrows,shadows,positioning,fit,calc,decorations.pathreplacing,decorations.pathmorphing,decorations.shapes,decorations.text,automata}
\tikzset{math mode/.style = {execute at begin node=$, execute at end node=$}}

%tikz
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% boxes
\tikzstyle{class}=[draw, text width=6em, minimum height=2.5em, text centered]
\tikzstyle{tool}= [draw, text width=8em, minimum height=2.5em, text centered, draw=RoyalBlue, fill=blue!15 ]
\tikzstyle{file} = [draw, text width=8em, minimum height=2.5em, text centered, draw=ForestGreen, fill=light-green, rounded corners]
\tikzstyle{state}=[circle, draw, align=center, minimum height=4em, anchor=north, inner sep=0]
\tikzstyle{group}=[inner sep=10pt,draw=gray, very thick, dotted, rounded corners=4pt]
\tikzstyle{netCloud}=[draw, text width=4em, minimum width =10em, minimum height=2em, text centered, cloud, cloud puffs = 15]

% arrows
\tikzstyle{arr}=[->, >=stealth', thick, gray, shorten >= 0.2mm]
\tikzstyle{aggregate}=[arr, >=open diamond]
\tikzstyle{extend}=[arr, >=open triangle 90]
%others
\tikzstyle{ann} = [above, text width=5em, text centered]

\usepackage[underline=false,rounded corners=true]{pgf-umlsd}

\lstset{literate=%
{√ñ}{{\"O}}1
{√Ñ}{{\"A}}1
{√ú}{{\"U}}1
{√ü}{{\ss}}2
{√º}{{\"u}}1
{√§}{{\"a}}1
{√∂}{{\"o}}1
{ùú∫}{{$\epsilon$}}1
{‚àß}{{$\wedge$}}1
{‚à®}{{$\vee$}}1
}

%listing languages
%\lstdefinelanguage{xcend}{
%  keywords={element, attribute, assert, exists, not exists, size, count, sum, tally, insert, update, delete, if, then, else, fi, at, to, %using},
%  comment=[l]{//},morecomment=[n]{/*}{*/}
%}

%\lstdefinelanguage{java}{backgroundcolor=\color{light-green}}

\lstset{
   %language=katja,
   basicstyle=\footnotesize,
   backgroundcolor=\color{light-green},
   frame=single,
   framerule=0pt
}

\renewcommand\arraystretch{1.2}

\brokenpenalty=1000
\widowpenalty=1000
\clubpenalty=1000

%% extension for pgf-umlsd v0.5 2009/09/30, which TeXLive comes along

%% \leftsidelabel{thread}{side}{label}
%% side: left right above below
\newcommand{\sidelabel}[3]{
    \stepcounter{seqlevel}
    \path
    (#1)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (messbeg) {};
    \draw (messbeg) node[#2] {#3};
}

%% mostly used between altblocks
%% \separateline[line style]{from}{to}
\newcommand{\separateline}[3][dotted, color=black, very thick]{
    \stepcounter{seqlevel}
    \path
    (#2)+(.1,-\theseqlevel*\unitfactor-.8*\unitfactor) node (from) {}
    (#3)+(-.1,-\theseqlevel*\unitfactor-.8*\unitfactor) node (to) {};
    \draw[#1] (from) -- (to);
}

%% \begin{altblock}{from}{condition}{to}
%% %%calls here
%% \end{altblock}
\newenvironment{altblock}[3]{
    \stepcounter{seqlevel}
    \path
    (#1)+(.1,-\theseqlevel*\unitfactor-\unitfactor) node (from) {}
    (#3)+(-.1,-\theseqlevel*\unitfactor-\unitfactor) node (to) {};
    \draw (from) node[above right] {[#2]};
}{}

%%
\newcommand{\postlevel}{\addtocounter{seqlevel}{+1}}

%% \newthread[thread distance]{color fill style}{left}{right}
%\renewcommand{\newthread}[4][1]{
%    \newinst[#1]{#3}{#4}
%    \stepcounter{threadnum}
%    \node[below of=inst\theinstnum,node distance=1em] (thread\thethreadnum) {};
%    \tikzstyle{threadcolor\thethreadnum}=[fill=#2]
%    \tikzstyle{instcolor#3}=[fill=#2]
%}


\begin{document}

\selectlanguage{english}
\title{HOPP Driver Generator Documentation}
\author{Thomas Fischer}
\date{\today}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\thispagestyle{empty}
\newpage



\chapter{Introduction}
\label{sec:intro}
This document is intended to give an overview over the HOPP Driver Generator for both, users and developers. While the first chapters are more addressed towards users of the generator, the later ones are more addressed towards developers. 

%define scope of the generator
The HOPP Driver Generator itself is intended to provide embedded system developers %that's kinda vague
with a simple, convenient interface to communicate with their designed hardware components. % that's not better...
To our knowledge, such an interface for communication with VHDL components has not been done so far, though extensive research exists concerning efficient communication between PCs and FPGAs over different communication channels, mainly Ethernet \cite{lofgren05, alachiotis10, alachiotis12}.

Our interface has been prototyped with a \texttt{C++} frontend communicating with a Xilinx Virtex 6 ML-605 FPGA over Ethernet. The design enables easy extension to support other frontend languages, FPGA boards or transport media.

\section{Origins and Goals}
\label{sec:goals}
The HOPP Driver Generator originally was and currently is developed by the Software Technology Group of the University of Kaiserslautern in cooperation with the Microelectronic Design Research Group of the University of Kaiserslautern.

The design goals of this project are:

\begin{itemize}
%those are not really "design" goals, but hey... text... for now
\item \textcolor{red}{Probably better filled out by the EIT department ;)}
\item An easy-to-use driver and driver generator
\item Well-documented api
\item Modularity and extensibility
\item Meaningful error description
\end{itemize}

\section{Terminology}
\label{sec:term}
This section explains the terminology used in this document and the project in general.

\paragraph{Driver}
The complete software product is called the \textit{driver}. It enables  \textcolor{red}{software-side} communication with the hardware platform.

\paragraph{Board / board-side}
The driver is split in two parts, one of which has to be uploaded and executed to the hardware platform itself. This part of the driver is referred to as board-side driver. Sometimes, the terms \textit{server} and \textit{server-side} might be used instead.

\paragraph{Host / host-side}
In contrast to the board-side driver, the host-side driver is the part of the driver which is located on the communicating computer. This part contains the actual API, embedded developers will work with. Sometimes, the terms \textit{client} and \textit{client-side} might be used instead.



\chapter{Getting Started}
\label{sec:start}
The purpose of this chapter is to explain how to properly build and use the generator. This part contains all steps required in order to run the generator and acquire drivers for the specified board.

\section{Setup}
\label{sec:setup}
In the following, the tools required to build and execute the driver generator are introduced. Please note, that all tools have to be executable from the command line. This requires (for example) Windows users to adjust their \texttt{PATH} variable.

\paragraph{Java}
The generator is implemented in Java due to tool support and the environment of the Software Technology Group. Consequently, a JDK version 6 or above is required. 

\paragraph{Gradle}
Gradle\footnote{available at \url{http://www.gradle.org/}} is a build tool, similar to \textit{Maven} or \textit{Ant} (like \textit{Make}, but - for the most part - easier to manage within larger projects). It supports the dependency management from Maven while retaining the flexibility of Ant. Plugins required by the build process are automatically downloaded by Gradle.

\paragraph{Mercurial}
Mercurial\footnote{available at \url{http://mercurial.selenic.com/}} is a distributed versioning tool, comparable with \textit{GIT}, \textit{Bazar} or (to some degree) \textit{Subversion}. The sources of the driver generator are located in a mercurial repository. If you acquired the sources (and this document) through other means mercurial is not required.

\paragraph{Doxygen}
Doxygen\footnote{available at \url{http://www.doxygen.org/}} is used for generation of a Java API-like html description of the driver API. While this generation is not required for the driver, it is highly recommended for easier integration of the generated driver.

\paragraph{\texttt{C/C++} Compiler}
Since the host side driver is written in \texttt{C++}, it is also required to have a \texttt{C/C++} compiler present.

\paragraph{Xilinx Toolsuite}
In order to generate an \texttt{.elf} file that can is used to program the FPGA, the Xilinx toolsuite is required. This includes ISE for generating IPCores out of VHDL files, XPS for composing these and EDK for actually generating the file for the defined hardware platform.

 \textcolor{red}{We try to avoid to require the user to actually design anything in the Xilinx suite, but only use it for synthesising the board hard- and software. Both, \texttt{.mhs} file and all source files for the EDK, are created by the driver generator.}

\textcolor{red}{It is furthermore desirable to skip user-interfaction with the EDK completely. This would require generation of the board support package and external call of Xilinx' compiler.}

\section{Process}
\label{sec:process}
If the tools described in \Cref{sec:setup} are correctly installed, the following steps should provide you with a working version of the driver generator.

%\begin{figure}
%\centering
%\begin{tikzpicture}
%\node[ann] (anchor) at (0,0) {};
%
%\node[class, below left = 0em and 4em] (build) at (anchor) {build generator (only once)};
%\node[class, below right = 0em and 4em] (dsl) at (anchor) {define VHDL files and DSL file};
%
%\node[class, below left = 6em and 4em] (gen) at (dsl) {run generator};
%\node[class, below right = 6e and 4em] (app) at (dsl) {write client application};
%
%\node[class, below left = 6em and 4em] (edk) at (gen) {build .elf with Xilinx EDK};
%\node[class, below right = 6em and 4em] (compile) at (gen) {compile composed application};
%
%\node[class, below left = 6em and 4em] (run) at (compile) {program fpga and run application};
%
%\draw[arr] (build) to node[auto] {} (gen);
%\draw[arr] (dsl) to node[auto] {} (gen);
%\draw[arr] (dsl) to node[auto] {} (app);
%
%\draw[arr] (gen) to node[auto] {} (edk);
%\draw[arr] (gen) to node[auto] {} (compile);
%\draw[arr] (app) to node[auto] {} (compile);
%
%\draw[arr] (edk) to node[auto] {} (run);
%\draw[arr] (compile) to node[auto] {} (run);
%\end{tikzpicture}
%\label{fig:workflow}
%\caption{Workflow when using the driver generator}
%\end{figure}

\subsection{Building the Generator}
First of all, the project has to be checked out. As of now, the project is only available at the mercurial repository of the Softech Group of the University of Kaiserslautern.\footnote{The repository is located at \url{https://softech.informatik.uni-kl.de/hg/ag/hopp/}. Please note, that authorization is required.}

After checking out the project, all sources have to be compiled and packaged. This can be done using the gradle build tool. The command to build a jar package is \texttt{gradle jar}. Simply type it in a shell in the project root repository, where the file \texttt{build.gradle} is located. Running the build file will generate an executable jar package under the path \texttt{<project>/build/libs}. Navigate there and try running it using the command \texttt{java -jar <name of the jar package>}.\footnote{This should result in the usage help and an error, since no .mhs file has been specified.} 

\subsection{Running the Generator}
The HOPP Driver Generator can be called using the command line interface (CLI). The CLI offers several parameters to further configure the run of the generator, listed in \Cref{tab:cliParams}.

\begin{table}
\centering
\begin{tabular}{ ll | p{9cm} } 
\hline
%\verb!-d! & \verb!--dest! & Specifies the destination directory. All files will be generated into the specified directory. If none is specified, the current working directory will be used instead.\\ \hline
\verb!-s! & \verb!--server! & Specifies the server backend. This specifies, for which target platform the driver should be generated. The default setting is a Virtex 6 ML 605 FPGA (currently, no other options are present).\\
& \verb!--serverDir! & Specifies the destination of the server directory. All files for the server (i.e. files used to generate the board side driver) will be generated into the specified directory. If none is specified, a directory "server" will be generated inside the current working directory.\\ \hline
\verb!-c! & \verb!--client! & Specifies the client backend. This specifies, in which language the client software should be generated. The default setting is a C++ frontend (currently, no other options are present).\\
& \verb!--clientDir! & Specifies the destination of the client directory. All client for the server will be generated into the specified directory. If none is specified, a directory "client" will be generated inside the current working directory.\\ \hline
\verb!-v! & \verb!--verbose! & The driver generator will print out additional console output. This makes it easier to track errors in the driver generator or the used source file.\\
\verb!-d! & \verb!--debug! & The driver will be generated with additional debug console output. This makes it easier to track errors in larger test cases.\\
\verb!-h! & \verb!--help! & Lists all CLI parameters and a short explanation. The generator will abort after parsing this parameter and not generate anything.\\ \hline
& \verb!--mac! & used to set the mac address of a possible Ethernet interface of the board. Notation: XX:XX:XX:XX:XX:XX, where each X marks a hexadecimal number (allowing lower as well as upper cases).\\
& \verb!--ip! & used to set the ip address of a possible Ethernet interface of the board. Notation: X.X.X.X, where each X marks a decimal number ranging from 0 to 255. The same notation is required for the following two parameters.\\
& \verb!--mask! & used to set the network mask of a possible Ethernet interface of the board.\\
& \verb!--gw! & used to set the standard gateway of a possible Ethernet interface of the board.\\
& \verb!--port! & used to set the communication port of a possible Ethernet interface of the board. \color{red}{Note that these five parameters are only contemporary and will be replaced by the new board description language (I hope - together with the debug parameter. It may be used for actually debugging the generator then ...).}\\ \hline

\end{tabular}
\caption{Summary of currently possible CLI parameters}
\label{tab:cliParams}
\end{table}

\begin{table}
\centering
\begin{tabular}{ ll | p{9cm} } 
\hline
%\verb!-d! & \verb!--dest! & Specifies the destination directory. All files will be generated into the specified directory. If none is specified, the current working directory will be used instead.\\ \hline
\verb!-p! & \verb!--project! & Specifies the project backend. This specifies, in which tool the hardware design should take place. Currently, only XPS in version 14.1 can be selected.\\\\ \hline

\end{tabular}
\caption{Summary of currently possible options for the Virtex6 server backend}
\label{tab:cppParams}
\end{table}

Additionally, the \texttt{.mhs} file of the system is required by the generator. So a complete call looks like the following line:\\

\texttt{java -jar driverGenerator.jar [OPTIONS] <.mhs file>}.\\

The output of the generator consists of two groups of files. The first group contains all files that make up the board side of the driver, which have to be compiled to an \texttt{.elf} file by the Xilinx SDK. The second group are files for the client side, that can be used to wrap communication with the board and its components.

In addition to the required sources, documentation for both host- and board-side sources is generated, using doxygen.

\subsection{Executing your Application}
Now the regular design process from Xilinx can be continued. The next step would be writing a host application that uses the generated host-side driver and API. After programming your FPGA with the \texttt{.elf} file generated using the board-side driver, your program should be able to communicate with VHDL components on the FPGA through this API.



\chapter{Driver Description}
This section should provide a conceptual overview of the driver parts. For pure users of the driver generator, only parts of the client side are really relevant. Developers might also be interested in the server part.

For a more detailed documentation of the code and provided methods, Javadoc style comments are provided, which can be transformed into an html or tex representation similar to the Java API specification using doxygen (see \Cref{sec:start} for details on how to enable documentation generation).

\begin{figure}[h]
\centering

\begin{tikzpicture}
%maybe also add networking components here... i.e. split the driver in two components - one handling communication with application/hardware, one handling networking - with another clearly defined interface. This allows better modularity and exchange of both parts individually. For example one could switch the communication channel without having to completely recompile the client-side communication. The question will be, how this can be made easy-to-use... Still, this modularity will ensure, that other transport mediums can be easily implemented. So if a transport over PCIE should be realised later, it is clear what functionality has to be provided --> clear interface definition!!

\node[netCloud] at (0,0) (cloud) {Transport Medium};

\node[class,fill=red!15, right=9em] (cdriver) at (cloud) {client-side driver};
\node[class, above=4em] (client) at (cdriver) {client application};

\node[class,fill=red!15, left=9em] (bdriver) at (cloud) {board-side driver};
\node[class,fill=white, below=4em] (vhdl3) at (bdriver) {};
\node[class,fill=white, above right = -2.72em and -6.9em of vhdl3] (vhdl2) {};
\node[class,fill=white,  above right = -3em and -6.9em of vhdl2] (vhdl1) {VHDL components};

\node[group, fit=(client) (cdriver), label={85:host side}] (hostSide) {};
\node[group, fit=(bdriver) (vhdl3) (vhdl2) (vhdl1), label={93:board side}] (boardSide) {};

\draw[arr,<->] (client) to node [auto] {} (cdriver);
\draw[arr,<->] (cdriver) to node [auto] {} (cloud);
\draw[arr,<->] (cloud) to node [auto] {} (bdriver);
\draw[arr,<->] (bdriver) to node [auto] {} (vhdl3);
\end{tikzpicture}
\caption{A high-level view of the data flow from a client application to vhdl components on the board through the generated driver}
\label{fig:dataFlow}
\end{figure}

The overall architecture of the driver is depicted by \Cref{fig:dataFlow}. Data is sent from an embedding client application to the client side driver. This driver communicates over some transport medium with the board side driver, which in turn distributes the received data to corresponding VHDL components on the FPGA. Results are sent back through the same chain.

\section{Host Side}
The client side consists of several cpp sources and headers files. These files can be imported in any client side project and be used to wrap communication with components on the board.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);
\node[class] (component) at (0,0) {Component};
\node[class, below left=5em and 6em] (interface) at (component) {Interface};
\node[class, below right=5em and 6em] (port) at (component) {Port};

\node[above=6em] (anchor_comp_if) at (interface) {};
\node[above=6em] (anchor_comp_port) at (port) {};

\node[class, gray, below=9em] (uart) at (interface) {USB/UART};
\node[class, gray, left=4em] (ethernet) at (uart) {Ethernet};
\node[class, gray, right=4em] (pcie) at (uart) {PCIE};

\node[above=2em] (anchor_ethernet) at (ethernet) {};
\node[above=2em] (anchor_uart) at (uart) {};
\node[above=2em] (anchor_pcie) at (pcie) {};

\node[class, gray, below left=4em and 0.5em] (in) at (port) {IN};
\node[class, gray, below right=4em and 0.5em] (out) at (port) {OUT};
\node[class, gray, below=9em] (dual) at (port) {DUAL};

\node[below=2.75em] (anchor_port) at (port) {};
\node[above=1.75em] (anchor_in_a) at (in) {};
\node[above=1.75em] (anchor_out_a) at (out) {};

\node[above=1.75em] (anchor_dual) at (dual) {};
\node[below=2.5em] (anchor_in_b) at (in) {};
\node[below=2.5em] (anchor_out_b) at (out) {};

\draw[arr, -, shorten >= -0.4em] (interface) to node[auto] {} (anchor_comp_if);
\draw[arr, -, shorten >= -0.4em] (port) to node[auto] {} (anchor_comp_port);

\draw[arr,-, shorten <= -0.35em] (anchor_comp_if) to node[auto] {} (component);
\draw[arr,-, shorten <= -0.35em] (anchor_comp_port) to node[auto] {} (component);

\node[ann, above left = 0em and 1.5em] (arr1) at (component) {1};
\node[ann, above right = 0em and 1.5em] (arr2) at (component) {1};

\node[ann, above right= 1.5em and -2em] (arr3) at (interface) {1};
\node[ann, above right = 1.5em and -1.5em] (arr4) at (port) {1..n};

\draw[arr,-, shorten >= -0.4em] (ethernet) to node[auto] {} (anchor_ethernet);
\draw[arr,-, shorten >= -0.4em] (pcie) to node[auto] {} (anchor_pcie);
\draw[arr,-, shorten >= -0.4em, shorten <= -0.4em] (anchor_ethernet) to node[auto] {} (anchor_pcie);
\draw[extend] (uart) to node[auto] {} (interface);

\draw[arr,-,shorten >= -0.4em] (in) to node[auto] {} (anchor_in_a);
\draw[arr,-,shorten >= -0.4em] (out) to node[auto] {} (anchor_out_a);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_a) to node[auto] {} (anchor_out_a);
\draw[extend, shorten <= -0.4em] (anchor_port) to node[auto] {} (port);

\draw[arr,-,shorten >= -0.4em] (dual) to node[auto] {} (anchor_dual);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (anchor_out_b);
\draw[extend, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (in);
\draw[extend, shorten <= -0.4em] (anchor_out_b) to node[auto] {} (out);

\end{tikzpicture}
\caption{Architecture of the host part}
\label{fig:archHost}
\end{figure}

The architecture of the host software is depicted in \Cref{fig:archHost}. The core concept of the host software is the \textit{component}. Such a component is a designed hardware unit, which can have several \textit{ports}, over which data can be sent to or received from the component. Hidden from the user, a component also has exactly one \textit{interface}, which handles actual communication.

\subsection{Component}
A component is a piece of designed hardware. It has multiple ports over which communication can take place, i.e. data is sent from or to the component, esp. the control ports \textit{clock} and \textit{reset}. Usually components receive data, process it and send back some results, though possibly on another port.

The host driver contains an abstract generic component, describing components in general. User-defined components have to be described in VHDL for embedded system design with the Xilinx toolsuite. Such VHDL definitions can be referenced in the board description language provided by the HOPP Driver Generator. For each user-defined core, a new subclass is created, which contains the specified ports. For each instance of a core on the board, an object of the cores subclass together with all its ports is instantiated in the driver respectively. Communication with the boards components happens through these objects.

All user-defined cores and instances of these cores can be found in components.h

\paragraph{GPIO compoments}
These components are specialised, predefined I/O components. Currently, three of these components are supported:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item LEDs
\item Switches
\item Buttons
\end{itemize}
Communication to these components is not handled via ports. Instead, it is possible to directly read or write the state of the component. LEDs can only be written to, switches and buttons can only be read from.

\subsection{Port}
 A port marks an AXI stream interface used to send data to or receive data from components. A port is always assigned to a single component, but a component can have multiple ports. Ports can be receiving ports, sending ports or bi-directional ports. They can have an arbitrary bitwidth, yet the bitwidth supported by the microblaze as well as the arm processor is limited to 32-bit. Also, the total number of ports is restricted in the microblaze / arm. We allow an arbitrary bitwidth and port number to retain generality of the driver for other platforms, but support arbitrary bidwidth translation and port number restriction to hide complexity from the user. The same applies for encoding format, i.e. the order of bits.

\subsection{Queues}
Writing data to these ports does not directly result in a message being sent to the board. Instead, written values are stored in a client-side queue for each port. This is done for the following reasons.

First of all, the client-side buffer is a method of \textcolor{red}{\textit{flow control}}. The board has only restricted resources and should not be flooded with more data than it can process. Consequently, data is stored on the client, if the board buffers have been filled and no more data can be received. 

Additionally, the client buffer offers \textcolor{red}{\textit{congestion control}}, since several small values can be packaged together in one message. This results in a smaller amount of messages being sent over the medium.

Similar queues exist for out-going ports. A read on such a port object does not read directly from the board, but from the local queue.

\subsection{I/O Threads}
The queues described above are filled asynchronously with two separate threads, a writing and a reading thread. High-level functionality of theses threads is rather self-explaining. The writing thread loops over all input queues and writes existing values on the medium. The reading thread does the opposite, i.e. listens to the medium and acts according to received messages (see \Cref{sec:protocol} for details about messages the server can send).

Both threads have to be started before using the API using \texttt{startup()} and should be shut down afterwards using \texttt{shutdown()}.

\subsection{Communication medium}
The communication medium is hidden from the user. Each driver is bound to a single communication medium, which wraps lower-level communication (essentially transport layer and below) between host and board driver. The communication medium abstracts from the actually used technology and provides a homogeneous api for the I/O threads. Network interface specific initialisation is generated as well and is not required by the user (other than annotating configuration details in the board description).

Currently, three communication mediums are envisioned:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{Ethernet Lite}, which is already implemented
\item \textbf{USB/UART}, which is considered as second interface and
\item \textbf{PCI Express}, which will not be implemented in the initial driver generator.
\end{itemize}

\paragraph{Ethernet Lite}
Communication over Ethernet is based on the lightweight IP stack, originally developed by Adam Dunkels\footnote{The lwip stack is documented with a wiki available at \url{http://lwip.wikia.com/wiki/LwIP_Wiki}}.

It is possible to implement more efficient Ethernet communication using dedicated VHDL components instead of running the lwip stack on the general purpose CPU. Such a component could easily be integrated in form of a new Communication Interface. An example for a dedicated VHDL communication component together with a client API is described in \cite{alachiotis10, alachiotis12}.

\textcolor{red}{Describe implementation of general interface methods in Ethernet as well as challenges and problems this interface poses.}

\paragraph{PCI Express}
\textcolor{red}{According to \cite{alachiotis10}, there exists a Xilinx wrapper for PCIE communication.}

\newpage
\section{Board Side}
The board-side driver consists of several files that can roughly be split into three groups: files handling communication with the host-side driver, files handling communication with board components and setup files.

All these files have to be imported in a new Xilinx SDK project started from an existing XPS project. The \texttt{.elf} file generated from this project then has to be uploaded to the target board.

\paragraph{Medium}
The medium folder contains a source and header file for the medium the board is attached to. In this file, medium-specific setup is performed and listening to incoming messages is handled. An incoming message is passed to the protocol interpreter, which distributes the content of the message in accordance to its header.

\paragraph{Components}
The components folder contains code for component-specific setup and communication between the boards general purpose cpu and designed IP cores. Code for controlling gpio components will also be generated in this folder.

\paragraph{Initialisation}
Files for initialisation are generated directly in the \texttt{src} folder of the project. Among these files is the \texttt{main.c}, which calls the initialisation procedures of the medium and all components and starts the scheduling loop. This loop performs three kinds of operations.

First, it checks for incoming messages and process their contents. Most of the time, this includes storing values in the in-going microblaze queue and acknowledging them. More details about message handling can be found in \Cref{sec:protocol}.

The loop also shifts messages from in-going microblaze queues to in-going hardware queues and vice versa from out-going hardware queues to out-going microblaze queues. 

Finally, the loop writes values from out-going microblaze queues on the medium.

\newpage
\section{Protocol}
\label{sec:protocol}
This section covers the transmission protocol between client and server application. Note that the protocol is base on the assumptions made above about client and server, specifically the used buffers and client I/O threads allowing parallelism with sending and receiving messages.

\subsection{State transitions}

Note: These calculi denote state transitions of a DFA. The precondition marks several conditions and an in-going message. The postcondition may contain an out-going message. Used messages are:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{wrt} An application writing values to the driver
\item \textbf{snd} Send values for a component to board
\item \textbf{ack} Receive ack for values from board
\item \textbf{poll} Receive poll from board
\end{itemize}

In addition, several functions have been used to simplify the calclui.
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{size(q)} The size of a value queue q
\item \textbf{drop(q, i)} Drops the first i values of a queue q
\item \textbf{first(q, i)} Obtain the first i values of a queue q. Returns a smaller array, if size(q) \textless ~i
\end{itemize}

The state is denoted by an array of value queues \textit{q} and an array of transit values \textit{s}. Both arrays are sized by the number of existing board components. The queues store values that should be received by the board, the transit values store the number of values currently in transit, i.e. that have been sent but not yet been acknowledged by the board.

\begin{mathpar}
\inferrule* [left=Write First] {q[a] = \emptyset \\ s[a] = 0 \\ wrt(a, v)}{q[a] = v \\ s[a] = size(first(v, n)) \\ snd(a, first(v, n))}
\end{mathpar}
Initially, the queue is empty and nothing has been sent. If a message is written in this state, store it in the queue, transmit the first n values and store the number of sent values.

%\begin{mathpar}
%\inferrule* [left=Write First] {q[a] = v \\ b[a] = true \\ s[a] = 0 }{q[a] = v \\ b[a] = false \\ s[a] = size(fist(v,n)) \\ snd(a, first(v,n))}
%\end{mathpar}
%If we have values to send and nothing has been sent so far (i.e. not waiting for a poll), send the first n values and set the send counter accordingly (we could also do this using an invalid send counter, e.g. -1, instead of a new variable).

\begin{mathpar}
\inferrule* [left=Write More] {q[a] = v \\ wrt(a, v')}{q[a] = v \oplus v'}
\end{mathpar}
If more values are received (i.e. while values are in transit), append the new values to the queue.

%replacing the Write First rule would require explicit treatment of this case, since the first flag has to be reset!
%\begin{mathpar}
%\inferrule* [left=Ack Full] {q[a] = v \\ s[a] = size(v) \\ ack(a, size(v))}{q[a] = \emptyset \\ s[a] = 0 \\ b[a] = true}
%\end{mathpar}
%If an acknowledgement is received, that acknowledges all sent data and no more data is in the queue, clear the queue and send %counter.

\begin{mathpar}
\inferrule* [left=Ack All] {q[a] = v \\ s[a] = i \\ ack(a, i)}{q[a] = drop(v,i) \\ s[a] = size(first(v,n)) \\ snd(a, first(v,n))}
\end{mathpar}
If all sent values are acknowledged, but the queue contains more values, remove the acknowledged values, send the next n values and set the send counter accordingly. If the queue is empty (i.e. no more data to send), \texttt{first} evaluates to the empty list. Do not send anything in this case.

\begin{mathpar}
\inferrule* [left=Ack Some] {q[a] = v \\ s[a] = i \\ ack(a, j) \\ j \textless i}{q[a] = drop(v,j) \\ s[a] = 0}
\end{mathpar}
If not all sent values have been acknowledged, clear the acknowledged ones, reset the send counter and wait for polls.

\begin{mathpar}
\inferrule* [left=Poll] {q[a] = v \\ s[a] = 0 \\ poll(a)}{q[a] = v \\ s[a] size(first(v, n)) \\ snd(a, first(v, n))}
\end{mathpar}
If a poll is received, send the first n values for the polled component and set the send counter. If the queue doesn't contain any values, \texttt{first} evaluates to the empty list. Do not send anything in this case.

\begin{mathpar}
\inferrule* [left=Poll Transit] {s[a] = i \\ i \textgreater 0 \\ poll(a)}{s[a] = i} % ignore polls, while data is in transit
\end{mathpar}
Ignore polls for components, which have unacknowledged data in transit. This catches the (unlikely) case of the last sent package (i.e. client queue is empty after sending this package) filling the server queue completely. The server will acknowledge all but will poll after the first value has been consumed.

%\begin{mathpar}
%\inferrule* [left=Total]
%  {\inferrule* [Left=Foo]
%     {\inferrule* [Right=Bar,
%                       leftskip=2em,rightskip=2em,vdots=1.5em]
%         {a \\ a \\\\ bb \\ cc \\ dd}
%         {ee}
%       \\ ff \\ gg}
%     {hh}
%  \\
%  \inferrule* [lab=XX]{uu \\ vv}{ww}}
%  {(1)}
%\end{mathpar}

\newpage
\subsection{Control Flow Graph}

\subsubsection{Host-side Driver}
In addition, to the control flow graph provided in \Cref{fig:cfg:client}, the host-side driver state is defined with two variables \texttt{q} and \texttt{s}. \texttt{q} denotes the host queue, while \texttt{s} stores the number of values in transit, i.e. those, that have been sent but not yet acknowledged. Finally, the value \texttt{n} represents the size of the board-side queue (which is defined by the user in the board specification file and therefore statically known by the generated driver).

Several variables occur in the control flow graph:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{v} Values of some sort (e.g. an array of integers)
\item \textbf{i} An unsigned (i.e. positive) integer number, smaller than \texttt{n}
\end{itemize}

In addition, several functions on parts of the state are introduced, to simplify the automaton.
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{size()} The number of values currently held by q
\item \textbf{empty()} \texttt{true}, if \texttt{size() == 0}, \texttt{false} otherwise
\item \textbf{drop(i)} Drops the first i values of q
\item \textbf{first(i)} Obtain the first i values of q. Returns a smaller array, if size() \textless ~i
\end{itemize}

Used messages are:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{wrt(v)} An application writing values to the driver. Appends \texttt{v} to \texttt{q}.
\item \textbf{snd(v)} Send values for a component to board. Sets \texttt{s} to \texttt{size(v)}.
\item \textbf{ack(i)} Receive ack for values from board. Receiving an \texttt{ack} resets \texttt{s} and also drops the values from \texttt{q}, i.e. \texttt{drop(i)}.
\item \textbf{poll} Receive poll from board.
\item \textbf{notify} Notifies the application of successful sending of all queued up messages.
\end{itemize}

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);

\node[state] (init) at (0,0) {Init};
\node[above left = 4em and 4em] (anchor) at (init){};
\node[state, below=10em] (wait) at (init) {Wait};
\node[state, below=10em] (idle) at (wait) {Idle};
\node[state, right=10em] (ack) at (wait) {Ack};

\draw[extend, black] (anchor) to node[auto] {} (init);
\draw[arr, black] (init) to node[midway, left=0.5em] {$\inferrule{wrt(v)}{snd(v)}$} (wait);
\draw[arr, black, bend left = 20] (wait) to node[midway, above] {$\inferrule{ack(i)~[i==s]}{ }$} (ack);
\draw[arr, black, bend left = 20] (ack) to node[near start, below=0.5em] {$\inferrule{[!q.empty()]}{snd(take(n))}$} (wait);
\draw[arr, black, bend right = 40] (ack) to node[midway, right=1em] {$\inferrule{[q.empty()]}{\textcolor{red}{notifiy()}}$} (init);
\draw[arr, black, bend left = 20] (wait) to node[near end, right=0.5em] {$\inferrule{ack(i)~[i<s]}{ }$} (idle);
\draw[arr, black, bend left = 20] (idle) to node[midway, left=0.5em] {$\inferrule{poll}{snd(take(n))}$} (wait);

\end{tikzpicture}
\label{fig:cfg:client}
\caption{Control flow graph of the host-side driver}
\end{figure}

Note, that this graph only addresses a single component. In a scenario with multiple components, an individual state exists for each component. A surrounding scheduler allows only a single automaton to make a transition.

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);

\node[state] (init) at (0,0) {Init};
\node[above left = 4em and 4em] (anchor) at (init){};
\node[state, below=10em] (wait) at (init) {Wait};
\node[state, below=10em] (idle) at (wait) {Idle};
\node[state, right=10em] (ack) at (wait) {Ack};

\draw[extend, black] (anchor) to node[auto] {} (init);
\draw[arr, black] (init) to node[midway, left=0.5em] {$\inferrule{rcv}{snd}$} (wait);
\draw[arr, black, bend left = 20] (wait) to node[midway, above] {$\inferrule{full~ack}{ }$} (ack);
\draw[arr, black, bend left = 20] (ack) to node[near start, below=0.5em] {$\inferrule{!isEmpty(queue)}{snd}$} (wait);
\draw[arr, black, bend right = 40] (ack) to node[midway, right=1em] {$\inferrule{isEmpty(queue)}{ }$} (init);
\draw[arr, black, bend left = 20] (wait) to node[near end, right=0.5em] {$\inferrule{partial~ack}{ }$} (idle);
\draw[arr, black, bend left = 20] (idle) to node[midway, left=0.5em] {$\inferrule{poll}{snd}$} (wait);

\end{tikzpicture}
\label{fig:cfg:clientSimp}
\caption{Simplified control flow graph of the host-side driver}
\end{figure}


\newpage

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);

\node[state] (listen) at (0,0) {Listen};
\node[above left = 4em and 4em] (anchor) at (listen){};
\node[state, below=10em] (read) at (listen) {Consume};

\draw[extend, black] (anchor) to node[auto] {} (listen);
\draw[arr, black, out=330,in=30,looseness=8] (listen) to node[midway, right=0.5em] {$\inferrule{snd(v)}{ack(store(i))}$} (listen);
\draw[arr, black, bend left=20] (listen) to node[midway, right=0.5em] {$\inferrule{schedule()}{ }$} (read);
\draw[arr, black, bend left=20] (read) to node[midway, left=0.5em] {$\inferrule{schedule()}{ }$} (listen);
\draw[arr, black, out=330, in=30, looseness=6] (read) to node[midway, right=0.5em] {$\inferrule{[!empty()]}{consume()}$} (read);

\end{tikzpicture}
\label{fig:cfg:clientSimp}
\caption{Control flow graph of the board-side driver}
\end{figure}


\newpage
\subsection{Sequence charts}
Some sequence charts to visualise the envisioned process. For example, \Cref{fig:seq:nbwrite} shows in detail, how a non-blocking write is handled. First of all, the values are stored client-side. The application receives a pointer to a \texttt{write} object, which represents the current state of the scheduled write, i.e. how many values have been received by the component on the server.

%write first & more
\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{app}{application}
  \newinst{cl}{client}
  \newinst{cq}{clientQueue}  

\begin{sdblock}{Write}{}
  \begin{call}{app}{nbwrite(a,v)}{cl}{write* w}
    \begin{call}{cl}{nbwrite(a,v)}{cq}{write* w}
    \end{call}
  \end{call}
\end{sdblock}
\end{sequencediagram}

\caption{An application writing values through the client-side driver api}
\label{fig:seq:clientWrite}
\end{figure}

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{cq}{clientQueue}  
  \newthread{io}{comHandler}
  \newinst{m}{medium}

\begin{sdblock}{Send}{}
  \begin{callself}{io}{schedule(a)}{}
    \begin{call}{io}{check(a)}{cq}{(v)}
    \end{call}
    \begin{call}{io}{send(a,v)}{m}{}
    \end{call}
  \end{callself}
\end{sdblock}
\end{sequencediagram}

\caption{A client sending data}
\label{fig:seq:clientSend}
\end{figure}


\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{cq}{clientQueue}  
  \newthread{io}{comHandler}
  \newinst{m}{medium}

\begin{sdblock}{Receive nb ACK}{}
 \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{(ack,a,s(v))}
    \end{call}
    \begin{call}{io}{remove(a,s(v))}{cq}{}
    \end{call}
    \begin{callself}{io}{update(w)}{}
    \end{callself}
  \end{callself}
\end{sdblock}
\end{sequencediagram}
\caption{The client-side driver receiving an acknowledgement from the server}
\label{fig:seq:clientAck}
\end{figure}

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{cq}{clientQueue}
  \newthread{io}{comHandler}
  \newinst{m}{medium}
\begin{sdblock}{Receive Poll}{}
  \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{(poll, a)}
    \end{call}
    \begin{call}{io}{getValues(a)}{cq}{(v)}
    \end{call}
    \begin{call}{io}{send(a,v)}{m}{}
    \end{call}
  \end{callself}
\end{sdblock}
\end{sequencediagram}
\caption{The client-side driver receiving a data request from the server}
\label{fig:seq:clientPoll}
\end{figure}

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{m}{medium}
  \newthread{ser}{server}
  \newinst{sq}{serverQueue}
 \begin{sdblock}{Server Read}{}
  \begin{callself}{ser}{schedule(read)}{}
    \begin{call}{ser}{recv()}{m}{(a,v)}
    \end{call}
    \begin{call}{ser}{store(a,v)}{sq}{}
    \end{call}
    \begin{call}{ser}{ack(a,v)}{m}{}
    \end{call}
  \end{callself}
\end{sdblock}
\end{sequencediagram}
\caption{The server-side driver receiving a data package from the client}
\label{fig:seq:serverRead}
\end{figure}

%Composition example
\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{app}{application}
  \newinst{cl}{client}
  \newinst{cq}{clientQueue}
  \newthread{io}{comHandler}
  \newinst{m}{medium}
  \newthread{ser}{server}
  \newinst{sq}{serverQueue}
\begin{sdblock}{Non-Blocking Write}{}
\node at (app) {};
\node at (cl) {};
\node at (cq) {};
\end{sdblock}
\begin{sdblock}{Send}{}
\node at (cq) {};
\node at (io) {};
\node at (m) {};
\end{sdblock}
\begin{sdblock}{Server Read}{}
\node at (m) {};
\node at (ser) {};
\node at (sq) {};
\end{sdblock}
\begin{sdblock}{Receive nb ACK}{}
\node at (cq) {};
\node at (io) {};
\node at (m) {};
\end{sdblock}
\end{sequencediagram}
\caption{Composed example of a non-blocking write using the building blocks defined before.}
\label{fig:seq:comp1}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Following are the complete use-cases... (which take about a page each)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{app}{application}
  \newinst{cl}{client}
  \newinst{cq}{clientQueue}
  \newthread{io}{comHandler}
  \newinst{m}{medium}
  \newthread{ser}{server}
  \newinst{sq}{serverQueue}
  
\begin{sdblock}{Non-Blocking Write}{}
  \begin{call}{app}{nbwrite(a,v)}{cl}{write* w}
    \begin{call}{cl}{nbwrite(a,v)}{cq}{write* w}
      %\begin{call}{io}{store(a,v)}{cq}{}
      %\end{call}
    \end{call}
  \end{call}

  \prelevel\prelevel
  \begin{callself}{io}{schedule(a)}{}
    \begin{call}{io}{check(a)}{cq}{(v)}
    \end{call}
    \begin{call}{io}{send(a,v)}{m}{}
    \end{call}
  \end{callself}

  \prelevel\prelevel
  \begin{callself}{ser}{schedule(read)}{}
    \begin{call}{ser}{recv()}{m}{(a,v)}
    \end{call}
    \begin{call}{ser}{store(a,v)}{sq}{s(v)}
    \end{call}
    \begin{call}{ser}{ack(a,s(v))}{m}{} % this is only the server-side ack, not the component ack!! for component ack, it has to be out of the mb queue!
    \end{call}
  \end{callself}

  \prelevel
  \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{(ack,a,s(v))}
    \end{call}
    \begin{callself}{io}{update(w)}{}
    \end{callself}
    \begin{call}{io}{remove(a,s(v))}{cq}{}
    \end{call}
  \end{callself}
\end{sdblock}

\end{sequencediagram}
\caption{A sequence diagram for a non-blocking write. Note, that non-blocking only means, the client does not wait for the target \textbf{component} to receive the message, but still waits for the client queue to receive the values.}
\label{fig:seq:nbwrite}
\end{figure}

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newthread{app}{application}
  \newinst{cl}{client}
  \newinst{cq}{clientQueue}
  \newthread{io}{comHandler}
  \newinst{m}{medium}
  \newthread{ser}{server}
  \newinst{sq}{serverQueue}
  
\begin{sdblock}{Blocking Write}{}
  \begin{call}{app}{write(a,v)}{cl}{}
    \begin{call}{cl}{write(a,v)}{cq}{}
      %\begin{call}{io}{store(a,v)}{cq}{}
      %\end{call}
% problem with this call over the first version: this doesn't directly inform the comHandler of NEW data for a component
% instead, when the handler schedules a component, he doesn't know if he should send data or wait for a poll.
% we COULD solve this with an additional boolean flag on client side.
% I'm not convinced, that the first version can be implemented, since it would basically circumvent the scheduler.
% alternative: remove the component from the list of components to schedule, if we wait for a poll or ack. This is handled in the recv phase of the scheduler
    \end{call}
    \begin{callself}{cl}{wait()}{}
    \postlevel\postlevel\postlevel\postlevel\postlevel\postlevel
    \postlevel\postlevel\postlevel\postlevel\postlevel\postlevel
    \postlevel\postlevel\postlevel\postlevel
    \end{callself}

    \prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel
    \prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel\prelevel
    \prelevel\prelevel\prelevel

    \begin{callself}{io}{schedule(a)}{}
      \begin{call}{io}{check(a)}{cq}{(v)}
      \end{call}
      \begin{call}{io}{send(a,v)}{m}{}
      \end{call}
    \end{callself}

    \prelevel\prelevel
    \begin{callself}{ser}{schedule(read)}{}
      \begin{call}{ser}{recv()}{m}{(a,v)}
      \end{call}
      \begin{call}{ser}{store(a,v)}{sq}{s(v)}
      \end{call}
      \begin{call}{ser}{ack(a,s(v))}{m}{} % this is only the server-side ack, not the component ack!! for component ack, it has to be out of the mb queue!
      \end{call}
    \end{callself}

    \prelevel
    \begin{callself}{io}{schedule(read)}{}
      \postlevel
      \begin{call}{io}{recv()}{m}{(ack,a,s(v))}
      \end{call}
      \begin{call}{io}{remove(a,s(v))}{cq}{}
      \end{call}
    \mess{io}{notify()}{cl}
    \end{callself}
  \prelevel
  \end{call}

\end{sdblock}

\end{sequencediagram}
\caption{A sequence diagram for a blocking write. Note, that only the application is blocked, not the communication handler, which may process non-blocking writes sent before the blocking write \textbf{after} the non-blocking write.}
\label{fig:seq:nbwrite}
\end{figure}


\begin{figure}[h]
\centering
\begin{sequencediagram}
  \tikzstyle{inststyle}+=[rounded corners=3.2mm, top color=gray!40]
  \newinst{cq}{clientQueue}
  \newthread{io}{comHandler}
  \newinst{m}{medium}
  \newthread{ser}{server}
  \newinst{sq}{serverQueue}

\begin{sdblock}{Polling}{}

  \begin{callself}{ser}{schedule(a)}{}
    \postlevel
    \begin{call}{ser}{hasSpace(a)}{sq}{true}
    \end{call}
    \begin{call}{ser}{poll(a)}{m}{}
    \end{call}
  \end{callself}

  \prelevel
  \begin{callself}{io}{schedule(read)}{}
    \postlevel
    \begin{call}{io}{recv()}{m}{(poll, a)}
    \end{call}
    \begin{call}{io}{getValues(a)}{cq}{(v)}
    \end{call}
    \begin{call}{io}{send(a,v)}{m}{}
    \end{call}
  \end{callself}

  \prelevel\prelevel
  \begin{callself}{ser}{schedule(read)}{}
    \begin{call}{ser}{recv()}{m}{(a,v)}
    \end{call}
    \begin{call}{ser}{store(a,v)}{sq}{}
    \end{call}
    \begin{call}{ser}{ack(a,v)}{m}{}
    \end{call}
  \end{callself}

    \prelevel
    \begin{callself}{io}{schedule(read)}{}
      \postlevel
      \begin{call}{io}{recv()}{m}{(ack,a,s(v))}
      \end{call}
      \begin{call}{io}{remove(a,s(v))}{cq}{}
      \end{call}
    \end{callself}

\end{sdblock}

\end{sequencediagram}
\caption{A polling scenario. The server scheduler reaches component a and registers free space in the queue (that was formerly full). He then polls values for component a. The poll triggers sending of data at the client, which is later received in a read phase of the server.}
\label{fig:seq:nbwrite}
\end{figure}

\chapter{Generator}
This chapter is used to explain the code generator itself. This information is intended for future developers of the driver generator.\textcolor{red}{A reference to the third Katja report might be useful.}

\section{Used Libraries}
This section gives a short overview over the used libraries and explains what for and why they are used. These libraries are included in the repository and build jar file and require no further user interaction. Still, as the generator code depends on them, they are introduced here for future developers.

\subsection{JFlex \& CUP}
\textcolor{red}{This can be kept short with a reference to the JFlex/Cup documentation}
Flex is a scanner generator, CUP a parser generator. Both together are currently used to parse \texttt{.mhs} files into abstract syntax trees. \textcolor{red}{In future versions, they will be used to parse the DSL of the driver generator.}

\subsection{Katja}
The driver generator uses the Katja tool, developed by the Software Technology Group of the University of Kaiserslautern. This tool generates several data types\footnote{Since these data types will be described using their Katja specifications, it is strongly recommended to read through the Katja specification provided in form of three technical reports at \url{https://softech.informatik.uni-kl.de/Homepage/Katja}}. To be more specific, it provides the AST build up by the CUP parser as well as a model of the \texttt{C/C++} language described in detail in \Cref{sec:cmodel}.

\section{Generation Process}
\label{sec:genprocess}
The overall process of the driver generator is described by \Cref{fig:genprocess}. The source \texttt{.mhs} file describing the system board design is first translated into an internal representation of the board, i.e. an abstract syntax tree. This AST is used as input for the generator, which in turn outputs models of all required header- and source files. These models are translated into files by the \texttt{C/C++} unparser.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);
\node[tool] (gen) at (0,0) {Generator};

\node[file, above=1cm] (ast) at (gen) {Board AST};
\node[tool, above=1cm] (parser) at (ast) {Scanner/Parser};
\node[file, above=1cm] (mhs) at (parser) {.mhs file};

%TODO there is probably a better way to draw this with tikz - but there always is a better way ;)
\node[file, below left = 1.5cm and 0cm of gen] (board3) {};
\node[file, above right = -2.8em and -9em of board3] (board2) {};
\node[file, above right = -2.8em and -9em of board2] (board1) {board files};

\node[file, below right = 1.5cm and 0cm of gen] (host3) {};
\node[file, above right = -2.8em and -9em of host3] (host2) {};
\node[file, above right = -2.8em and -9em of host2] (host1) {host files};

\node[group, fit=(board1) (board2) (board3), label={95:board side}] (board) {};
\node[group, fit=(host1) (host2) (host3), label={75:host side}] (host) {};

\draw[arr] (mhs) to node[auto] {input} (parser);
\draw[arr] (parser) to node[auto] {generates} (ast);
\draw[arr] (ast) to node[auto] {input} (gen);
\draw[arr] (gen) to node[left] {generates} (board);
\draw[arr] (gen) to node[right] {generates} (host);

\draw[arr, <->] (board) to node[below] {communicate} (host);
\end{tikzpicture}
\caption{A rough sketch of the translation process so far}
\label{fig:genprocess}
\end{figure}

\section{CModel}
\label{sec:cmodel}
%TODO completely outdated, but don't want to update this part before all changes are finalised...
The \texttt{C} model provides data types representing a \texttt{C/C++} program. Note, that the model is neither complete nor always valid, i.e. not all \texttt{C} programs can be described using this model and it is possible to specify a model not translating into valid \texttt{C}. Still, the model simplifies the process of code generation. The model is used for generating \texttt{C} as well as \texttt{C++} code.

\begin{lstlisting}[language=java, breaklines=true]
MFile ( MDocumentation doc, String name, MDefinitions defs, MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses classes )

MClass ( MDocumentation doc, MModifiers modifiers, String name, MTypes extend, MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses nested )

MModifier = PRIVATE() | PUBLIC() | CONSTANT() | STATIC() | INLINE()
\end{lstlisting}

First of all, files can be documented using an \texttt{MDocumentation} element. If the documentation is not empty, a \texttt{@file} tag is attached to indicate this as a file documentation for doxygen.  A file has a name and consists of several definitions, structures, enums, attributes and methods. Files also can contain several classes. These classes again have a name and can contain all these components including other classes. In addition, classes can contain modifiers and inherit components from other classes. Classes also can be documented.
The allowed modifiers are private, public, constant, static, and inline. Note, that not all of these modifiers are class modifiers, and several combinations of modifiers are invalid (e.g. private and public). The model relies on the developer to choose modifiers according to the modified program part.

\begin{lstlisting}[language=java, breaklines=true]
MDefinition ( MDocumentation doc, String name, String value)
MStruct ( MDocumentation doc, MModifiers modifiers, String name, MAttributes attributes )
MEnum   ( MDocumentation doc, MModifiers modifiers, String name, Strings values )
\end{lstlisting}

Definitions, structs and enums mark rather trivial tuple productions. A definition simply assigns a name to a value. %something about structs
Enums list a number of possible values. All three can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MAttribute ( MDocumentation doc, MModifiers modifiers, MAnyType type, String name, MCodeFragment initial )
MCodeFragment ( String part, MIncludes needed )
\end{lstlisting}

Attributes are similar to definitions, but are typed and may also be left unassigned, using an empty code fragment. The \texttt{MIncludes} is required if the type of the attribute is not defined within this c file itself. They also can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MMethod ( MDocumentation doc, MModifiers modifiers, MReturnType returnType, String name, MParameters parameter, MCode body )

MReturnType = MAnyType | MVoid() | MNone()

MParameter ( MParamType refType, MAnyType type, String name )
MParamType  = VALUE() | REFERENCE() | CONSTREF()

MCode ( Strings lines, MIncludes needed )
\end{lstlisting}

Methods have a return type and a list of parameters. The method body is also more complex than a simple code fragment and can consist of several lines, which are not checked any further in this model. The return type can be any \texttt{C} type as well as void. For constructors in \texttt{C++}, the return type \texttt{MNone} is used. Parameters also have a type and name. Furthermore, the mode of parameter passing has to be specified.

\begin{lstlisting}[language=java, breaklines=true]
MAnyType = MType             ( String name )
         | MArrayType        ( MAnyType type, Integer length )
         | MPointerType      ( MAnyType type )
         | MConstPointerType ( MAnyType type )
\end{lstlisting}

The type system of the model supports arrays as well as (const) pointers. The basic type is the \texttt{MType}, which consists only of a string that has to reference an existing \texttt{C} type, e.g. \texttt{int}, \texttt{struct student} or \texttt{enum day}. This type can then be extended using pointer or array types. So \texttt{MArrayType(MType("int"), 5)} would mark an integer array of length 5. Note, that these types are nested semantically rather than in the same order as in \texttt{C}. Consequently, a point type of a const pointer type of type integer will be translated into \texttt{int const ** a}.

\begin{lstlisting}[language=java, breaklines=true]
MDocumentation ( Strings doc, MTags tags )

MTag = PARAM      ( String name, Strings details )
     | RETURN     ( Strings details )
     | THROWS     ( String type, Strings details )
     | DEPRECATED ( Strings details ) 
     | SEE        ( String see )
     | AUTHOR     ( String name )
     | SINCE      ( String date )
\end{lstlisting}

For generation of the API, Javadoc style documentation has to be added to the model. A \texttt{MDocumentation} element contains documentation for the following block as well as possibly several tags. Tags can be parameter or return value descriptions of a method/procedure, descriptions for exception behaviour, deprecation descriptions or references to other elements of the code. The \texttt{JAVADOC\_AUTOBRIEF} option is set in the generated doxygen config files, resulting in the first sentence (concluded by a dot and following space or newline) will be used as short description for the documented program part. Since neither the driver generator nor doxygen perform sanity checks, we rely on the user to only introduce meaningful tags for a documentation element. Note further, that the order of tags influences the order of elements in the generated API description.

\section{Unparser}
Different unparsers are used, to translate the \texttt{C} model in actual code. For each instance of the model, a header file and a corresponding source file, either \texttt{C} or \texttt{C++}, has to be generated. These unparsers are called depending on the particular instance of the model. Files intended to be loaded to the board have to be plain \texttt{C}, files intended for the client side can also be \texttt{C++} files. The unparsing itself is realized using the visitor pattern. Each visit method appends code to a string buffer depending on the visited element.

\paragraph{Header Unparser}
The header unparser is used for both, unparsing \texttt{C} as well as \texttt{C++} code. Consequently, it doesn't filter any constructs, but accepts everything specifiable with the model.

This unparser generates only signatures for all methods and only the declarations of attributes and enums. However, the header file will contain all includes referenced within the model.

\paragraph{Plain \texttt{C} Unparser}
Since plain \texttt{C} doesn't have any concept of classes, using a model with classes in this unparser will result in exceptions. Otherwise, all components and combinations are accepted. The source file will only import the corresponding header file, no other headers or sourcefiles.

\paragraph{\texttt{C++} Unparser}
For the \texttt{C++} unparser, like with the header unparser, every component and combination is allowed. The source file will only import the corresponding header file, no other headers or sourcefiles.



\addtocontents{toc}{\protect\vspace*{\fill}}

\newpage
\pagestyle{empty}
\bibliography{bib}
\bibliographystyle{splncs03}
\end{document}