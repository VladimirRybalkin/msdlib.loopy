\documentclass{report}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english,german]{babel}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
\usepackage[nameinlink]{cleveref}
%\usepackage{alltt}
%\usepackage{multirow}
%\usepackage{rotating}
\usepackage{listings}
\usepackage{setspace}
\usepackage{mathpartir}

%\usepackage{fancyhdr}
%\setlength{\headheight}{15.2pt}

\usepackage[%gray,
      dvipsnames,svgnames]{xcolor}
\definecolor{light-green}{rgb}{0.9,1,0.85}

\usepackage{tikz}
\usetikzlibrary{shapes,matrix,arrows,shadows,positioning,fit,calc,decorations.pathreplacing,decorations.pathmorphing,decorations.shapes,decorations.text,automata}
\tikzset{math mode/.style = {execute at begin node=$, execute at end node=$}}

%tikz
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% boxes
\tikzstyle{class}=[draw, text width=6em, minimum height=2.5em, text centered]
\tikzstyle{tool}= [draw, text width=8em, minimum height=2.5em, text centered, draw=RoyalBlue, fill=blue!15 ]
\tikzstyle{file} = [draw, text width=8em, minimum height=2.5em, text centered, draw=ForestGreen, fill=light-green, rounded corners]
\tikzstyle{group}=[inner sep=10pt,draw=gray, very thick, dotted, rounded corners=4pt]
\tikzstyle{netCloud}=[draw, text width=4em, minimum width =10em, minimum height=2em, text centered, cloud, cloud puffs = 15]

% arrows
\tikzstyle{arr}=[->, >=stealth', thick, gray, shorten >= 0.2mm]
\tikzstyle{aggregate}=[arr, >=open diamond]
\tikzstyle{extend}=[arr, >=open triangle 90]
%others
\tikzstyle{ann} = [above, text width=5em, text centered]

\lstset{literate=%
{√ñ}{{\"O}}1
{√Ñ}{{\"A}}1
{√ú}{{\"U}}1
{√ü}{{\ss}}2
{√º}{{\"u}}1
{√§}{{\"a}}1
{√∂}{{\"o}}1
{ùú∫}{{$\epsilon$}}1
{‚àß}{{$\wedge$}}1
{‚à®}{{$\vee$}}1
}

%listing languages
%\lstdefinelanguage{xcend}{
%  keywords={element, attribute, assert, exists, not exists, size, count, sum, tally, insert, update, delete, if, then, else, fi, at, to, %using},
%  comment=[l]{//},morecomment=[n]{/*}{*/}
%}

%\lstdefinelanguage{java}{backgroundcolor=\color{light-green}}

\lstset{
   %language=katja,
   basicstyle=\footnotesize,
   backgroundcolor=\color{light-green},
   frame=single,
   framerule=0pt
}

\renewcommand\arraystretch{1.2}

\brokenpenalty=1000
\widowpenalty=1000
\clubpenalty=1000

\begin{document}

\selectlanguage{english}
\title{HOPP Driver Generator Documentation}
\author{Thomas Fischer}
\date{\today}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\thispagestyle{empty}
\newpage



\chapter{Introduction}
\label{sec:intro}
This document is intended to give an overview over the HOPP Driver Generator for both, users and developers. While the first chapters are more addressed towards users of the generator, the later ones are more addressed towards developers. 

%define scope of the generator
The HOPP Driver Generator itself is intended to provide embedded system developers %that's kinda vague
with a simple, convenient interface to communicate with their designed hardware components. % that's not better...
To our knowledge, such an interface for communication with VHDL components has not been done so far, though extensive research exists concerning efficient communication between PCs and FPGAs over different communication channels, mainly Ethernet \cite{lofgren05, alachiotis10, alachiotis12}.

Our interface has been prototyped with a \texttt{C++} frontend communicating with a Xilinx Virtex 6 ML-605 FPGA over Ethernet. The design enables easy extension to support other frontend languages, FPGA boards or transport media.

\section{Origins and Goals}
\label{sec:goals}
The HOPP Driver Generator originally was and currently is developed by the Software Technology Group of the University of Kaiserslautern in cooperation with the Microelectronic Design Research Group of the University of Kaiserslautern.

The design goals of this project are:

\begin{itemize}
%those are not really "design" goals, but hey... text... for now
\item \textcolor{red}{Probably better filled out by the EIT department ;)}
\item An easy-to-use driver and driver generator
\item Well-documented api
\item Modularity and extensibility
\item Meaningful error description
\end{itemize}

\section{Terminology}
\label{sec:term}
This section explains the terminology used in this document and the project in general.

\paragraph{Driver}
The complete software product is called the \textit{driver}. It enables  \textcolor{red}{software-side} communication with the hardware platform.

\paragraph{Board / board-side}
The driver is split in two parts, one of which has to be uploaded and executed to the hardware platform itself. This part of the driver is referred to as board-side driver. Sometimes, the terms \textit{server} and \textit{server-side} might be used instead.

\paragraph{Host / host-side}
In contrast to the board-side driver, the host-side driver is the part of the driver which is located on the communicating computer. This part contains the actual API, embedded developers will work with. Sometimes, the terms \textit{client} and \textit{client-side} might be used instead.



\chapter{Getting Started}
\label{sec:start}
The purpose of this chapter is to explain how to properly build and use the generator. This part contains all steps required in order to run the generator and acquire drivers for the specified board.

\section{Setup}
\label{sec:setup}
In the following, the tools required to build and execute the driver generator are introduced. Please note, that all tools have to be executable from the command line. This requires (for example) Windows users to adjust their \texttt{PATH} variable.

\paragraph{Java}
The generator is implemented in Java due to tool support and the environment of the Software Technology Group. Consequently, a JDK version 6 or above is required. 

\paragraph{Gradle}
Gradle\footnote{available at \url{http://www.gradle.org/}} is a build tool, similar to \textit{Maven} or \textit{Ant} (like \textit{Make}, but - for the most part - easier to manage within larger projects). It supports the dependency management from Maven while retaining the flexibility of Ant. Plugins required by the build process are automatically downloaded by Gradle.

\paragraph{Mercurial}
Mercurial\footnote{available at \url{http://mercurial.selenic.com/}} is a distributed versioning tool, comparable with \textit{GIT}, \textit{Bazar} or (to some degree) \textit{Subversion}. The sources of the driver generator are located in a mercurial repository. If you acquired the sources (and this document) through other means mercurial is not required.

\paragraph{Doxygen}
Doxygen\footnote{available at \url{http://www.doxygen.org/}} is used for generation of a Java API-like html description of the driver API. While this generation is not required for the driver, it is highly recommended for easier integration of the generated driver.

\paragraph{\texttt{C/C++} Compiler}
Since the host side driver is written in \texttt{C++}, it is also required to have a \texttt{C/C++} compiler present.

\paragraph{Xilinx Toolsuite}
In order to generate an \texttt{.elf} file that can is used to program the FPGA, the Xilinx toolsuite is required. This includes ISE for generating IPCores out of VHDL files, XPS for composing these and EDK for actually generating the file for the defined hardware platform.

 \textcolor{red}{It MIGHT also be possible to generate .mhs files or whatever the newer format is out of our DSL or replace our DSL with this language, which reduces the number of files that have to be written by the user...}

\textcolor{red}{It is furthermore desirable to skip user-interfaction with the EDK completely. This would require generation of the board support package and external call of Xilinx' compiler.}

\section{Process}
\label{sec:process}
If the tools described in \Cref{sec:setup} are correctly installed, the following steps should provide you with a working version of the driver generator.

%\begin{figure}
%\centering
%\begin{tikzpicture}
%\node[ann] (anchor) at (0,0) {};
%
%\node[class, below left = 0em and 4em] (build) at (anchor) {build generator (only once)};
%\node[class, below right = 0em and 4em] (dsl) at (anchor) {define VHDL files and DSL file};
%
%\node[class, below left = 6em and 4em] (gen) at (dsl) {run generator};
%\node[class, below right = 6em and 4em] (app) at (dsl) {write client application};
%
%\node[class, below left = 6em and 4em] (edk) at (gen) {build .elf with Xilinx EDK};
%\node[class, below right = 6em and 4em] (compile) at (gen) {compile composed application};
%
%\node[class, below left = 6em and 4em] (run) at (compile) {program fpga and run application};
%
%\draw[arr] (build) to node[auto] {} (gen);
%\draw[arr] (dsl) to node[auto] {} (gen);
%\draw[arr] (dsl) to node[auto] {} (app);
%
%\draw[arr] (gen) to node[auto] {} (edk);
%\draw[arr] (gen) to node[auto] {} (compile);
%\draw[arr] (app) to node[auto] {} (compile);
%
%\draw[arr] (edk) to node[auto] {} (run);
%\draw[arr] (compile) to node[auto] {} (run);
%\end{tikzpicture}
%\label{fig:workflow}
%\caption{Workflow when using the driver generator}
%\end{figure}

\subsection{Building the Generator}
First of all, the project has to be checked out. As of now, the project is only available at the mercurial repository of the Softech Group of the University of Kaiserslautern.\footnote{The repository is located at \url{https://softech.informatik.uni-kl.de/hg/ag/hopp/}. Please note, that authorization is required.}

After checking out the project, all sources have to be compiled and packaged. This can be done using the gradle build tool. The command to build a jar package is \texttt{gradle jar}. Simply type it in a shell in the project root repository, where the file \texttt{build.gradle} is located. Running the build file will generate an executable jar package under the path \texttt{<project>/build/libs}. Navigate there and try running it using the command \texttt{java -jar <name of the jar package>}.\footnote{This should result in the usage help and an error, since no .mhs file has been specified.} 

\subsection{Running the Generator}
The HOPP Driver Generator can be called using the command line interface (CLI). The CLI offers several parameters to further configure the run of the generator, listed in \Cref{tab:cliParams}.

\begin{table}
\centering
\begin{tabular}{ ll | p{9cm} } 
\hline
%\verb!-d! & \verb!--dest! & Specifies the destination directory. All files will be generated into the specified directory. If none is specified, the current working directory will be used instead.\\ \hline
\verb!-s! & \verb!--server! & Specifies the destination of the server directory. All files for the server (i.e. files used to generate the board side driver) will be generated into the specified directory. If none is specified, a directory "server" will be generated inside the current working directory.\\
\verb!-c! & \verb!--client! & Specifies the destination of the client directory. All client for the server will be generated into the specified directory. If none is specified, a directory "client" will be generated inside the current working directory.\\ \hline
\verb!-v! & \verb!--verbose! & The driver generator will print out additional console output. This makes it easier to track errors in the driver generator or the used source file.\\
\verb!-d! & \verb!--debug! & The driver will be generated with additional debug console output. This makes it easier to track errors in larger test cases.\\
\verb!-h! & \verb!--help! & Lists all CLI parameters and a short explanation. The generator will abort after parsing this parameter and not generate anything.\\ \hline
& \verb!--mac! & used to set the mac address of a possible Ethernet interface of the board. Notation: XX:XX:XX:XX:XX:XX, where each X marks a hexadecimal number (allowing lower as well as upper cases).\\
& \verb!--ip! & used to set the ip address of a possible Ethernet interface of the board. Notation: X.X.X.X, where each X marks a decimal number ranging from 0 to 255. The same notation is required for the following two parameters.\\
& \verb!--mask! & used to set the network mask of a possible Ethernet interface of the board.\\
& \verb!--gw! & used to set the standard gateway of a possible Ethernet interface of the board.\\
& \verb!--port! & used to set the communication port of a possible Ethernet interface of the board. \color{red}{Note that these five parameters are only contemporary and will be replaced by the new board description language (I hope - together with the debug parameter. It may be used for actually debugging the generator then ...).}\\ \hline

\end{tabular}
\caption{Summary of currently possible CLI parameters}
\label{tab:cliParams}
\end{table}

Additionally, the \texttt{.mhs} file of the system is required by the generator. So a complete call looks like the following line:\\

\texttt{java -jar driverGenerator.jar [OPTIONS] <.mhs file>}.\\

The output of the generator consists of two groups of files. The first group contains all files that make up the board side of the driver, which have to be compiled to an \texttt{.elf} file by the Xilinx SDK. The second group are files for the client side, that can be used to wrap communication with the board and its components.

In addition to the required sources, documentation for both host- and board-side sources is generated, using doxygen.

\subsection{Executing your Application}
Now the regular design process from Xilinx can be continued. The next step would be writing a host application that uses the generated host-side driver and API. After programming your FPGA with the \texttt{.elf} file generated using the board-side driver, your program should be able to communicate with VHDL components on the FPGA through this API.



\chapter{Driver Description}
This section should provide a conceptual overview of the driver parts. For pure users of the driver generator, only parts of the client side are really relevant. Developers might also be interested in the server part.

For a more detailed documentation of the code and provided methods, Javadoc style comments are provided, which can be transformed into an html or tex representation similar to the Java API specification using doxygen (see \Cref{sec:start} for details on how to enable documentation generation).

%\begin{figure}
%\centering
%\begin{tikzpicture}
%\node[class] (client) at (0,0) {client application};
%\node[class,fill=red!15, left=6em] (cdriver) at (client) {client-side driver};
%\node[class,fill=red!15, left=6em] (bdriver) at (cdriver) {board-side driver};
%
%\node[class,fill=white, left=6em] (vhdl3) at (bdriver) {};
%\node[class,fill=white, above right = -2.72em and -6.9em of vhdl3] (vhdl2) {};
%\node[class,fill=white,  above right = -3em and -6.9em of vhdl2] (vhdl1) {VHDL components};
%
%\node[group, fit=(client) (cdriver), label={30:host side}] (hostSide) {};
%\node[group, fit=(bdriver) (vhdl3) (vhdl2) (vhdl1), label={145:board side}] (boardSide) {};
%
%\draw[arr,<->] (client) to node [auto] {} (cdriver);
%\draw[arr,<->] (cdriver) to node [auto] {} (bdriver);
%\draw[arr,<->] (bdriver) to node [auto] {} (vhdl3);
%
%\end{tikzpicture}
%\caption{The order in which data is sent from a client application to a VHDL component}
%\label{fig:dataFlow}
%\end{figure}

\begin{figure}[h]
\centering

\begin{tikzpicture}
%maybe also add networking components here... i.e. split the driver in two components - one handling communication with application/hardware, one handling networking - with another clearly defined interface. This allows better modularity and exchange of both parts individually. For example one could switch the communication channel without having to completely recompile the client-side communication. The question will be, how this can be made easy-to-use... Still, this modularity will ensure, that other transport mediums can be easily implemented. So if a transport over PCIE should be realised later, it is clear what functionality has to be provided --> clear interface definition!!

\node[netCloud] at (0,0) (cloud) {Transport Medium};

\node[class,fill=red!15, right=9em] (cdriver) at (cloud) {client-side driver};
\node[class, above=4em] (client) at (cdriver) {client application};

\node[class,fill=red!15, left=9em] (bdriver) at (cloud) {board-side driver};
\node[class,fill=white, below=4em] (vhdl3) at (bdriver) {};
\node[class,fill=white, above right = -2.72em and -6.9em of vhdl3] (vhdl2) {};
\node[class,fill=white,  above right = -3em and -6.9em of vhdl2] (vhdl1) {VHDL components};

\node[group, fit=(client) (cdriver), label={85:host side}] (hostSide) {};
\node[group, fit=(bdriver) (vhdl3) (vhdl2) (vhdl1), label={93:board side}] (boardSide) {};

\draw[arr,<->] (client) to node [auto] {} (cdriver);
\draw[arr,<->] (cdriver) to node [auto] {} (cloud);
\draw[arr,<->] (cloud) to node [auto] {} (bdriver);
\draw[arr,<->] (bdriver) to node [auto] {} (vhdl3);
\end{tikzpicture}
\caption{A high-level view of the data flow from a client application to vhdl components on the board through the generated driver}
\label{fig:dataFlow}
\end{figure}

The overall architecture of the driver is depicted by \Cref{fig:dataFlow}. Data is sent from an embedding client application to the client side driver. This driver communicates over some transport medium with the board side driver, which in turn distributes the received data to corresponding VHDL components on the FPGA. Results are sent back through the same chain.

\section{Host Side}
The client side consists of several cpp sources and headers files. These files can be imported in any client side project and be used to wrap communication with components on the board.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);
\node[class] (component) at (0,0) {Component};
\node[class, below left=5em and 6em] (interface) at (component) {Interface};
\node[class, below right=5em and 6em] (port) at (component) {Port};

\node[above=6em] (anchor_comp_if) at (interface) {};
\node[above=6em] (anchor_comp_port) at (port) {};

\node[class, gray, below=9em] (uart) at (interface) {USB/UART};
\node[class, gray, left=4em] (ethernet) at (uart) {Ethernet};
\node[class, gray, right=4em] (pcie) at (uart) {PCIE};

\node[above=2em] (anchor_ethernet) at (ethernet) {};
\node[above=2em] (anchor_uart) at (uart) {};
\node[above=2em] (anchor_pcie) at (pcie) {};

\node[class, gray, below left=4em and 0.5em] (in) at (port) {IN};
\node[class, gray, below right=4em and 0.5em] (out) at (port) {OUT};
\node[class, gray, below=9em] (dual) at (port) {DUAL};

\node[below=2.75em] (anchor_port) at (port) {};
\node[above=1.75em] (anchor_in_a) at (in) {};
\node[above=1.75em] (anchor_out_a) at (out) {};

\node[above=1.75em] (anchor_dual) at (dual) {};
\node[below=2.5em] (anchor_in_b) at (in) {};
\node[below=2.5em] (anchor_out_b) at (out) {};

\draw[arr, -, shorten >= -0.4em] (interface) to node[auto] {} (anchor_comp_if);
\draw[arr, -, shorten >= -0.4em] (port) to node[auto] {} (anchor_comp_port);

\draw[arr,-, shorten <= -0.35em] (anchor_comp_if) to node[auto] {} (component);
\draw[arr,-, shorten <= -0.35em] (anchor_comp_port) to node[auto] {} (component);

\node[ann, above left = 0em and 1.5em] (arr1) at (component) {1};
\node[ann, above right = 0em and 1.5em] (arr2) at (component) {1};

\node[ann, above right= 1.5em and -2em] (arr3) at (interface) {1};
\node[ann, above right = 1.5em and -1.5em] (arr4) at (port) {1..n};

\draw[arr,-, shorten >= -0.4em] (ethernet) to node[auto] {} (anchor_ethernet);
\draw[arr,-, shorten >= -0.4em] (pcie) to node[auto] {} (anchor_pcie);
\draw[arr,-, shorten >= -0.4em, shorten <= -0.4em] (anchor_ethernet) to node[auto] {} (anchor_pcie);
\draw[extend] (uart) to node[auto] {} (interface);

\draw[arr,-,shorten >= -0.4em] (in) to node[auto] {} (anchor_in_a);
\draw[arr,-,shorten >= -0.4em] (out) to node[auto] {} (anchor_out_a);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_a) to node[auto] {} (anchor_out_a);
\draw[extend, shorten <= -0.4em] (anchor_port) to node[auto] {} (port);

\draw[arr,-,shorten >= -0.4em] (dual) to node[auto] {} (anchor_dual);
\draw[arr,-,shorten >= -0.4em, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (anchor_out_b);
\draw[extend, shorten <= -0.4em] (anchor_in_b) to node[auto] {} (in);
\draw[extend, shorten <= -0.4em] (anchor_out_b) to node[auto] {} (out);

\end{tikzpicture}
\caption{Architecture of the host part}
\label{fig:archHost}
\end{figure}

The architecture of the host software is depicted in \Cref{fig:archHost}. The core concept of the host software is the \textit{component}. Such a component is a designed hardware unit, which can have several \textit{ports}, over which data can be sent to or received from the component. Hidden from the user, a component also has exactly one \textit{interface}, which handles actual communication.

\subsection{Component}
A component is a piece of designed hardware. It has multiple ports over which communication can take place, i.e. data is sent from or to the component, esp. the control ports \textit{clock} and \textit{reset}. Usually components receive data, process it and send back some results, though possibly on another port.

The host driver contains an abstract generic component, describing components in general. User-defined components have to be described in VHDL for embedded system design with the Xilinx toolsuite. Such VHDL definitions can be referenced in the board description language provided by the HOPP Driver Generator. For each user-defined core, a new subclass is created, which contains the specified ports. For each instance of a core on the board, an object of the cores subclass together with all its ports is instantiated in the driver respectively. Communication with the boards components happens through these objects.

All user-defined cores and instances of these cores can be found in components.h

\paragraph{GPIO compoments}
These components are specialised, predefined I/O components. Currently, three of these components are supported:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item LEDs
\item Switches
\item Buttons
\end{itemize}
Communication to these components is not handled via ports. Instead, it is possible to directly read or write the state of the component. LEDs can only be written to, switches and buttons can only be read from.

\subsection{Port}
 A port marks an AXI stream interface used to send data to or receive data from components. A port is always assigned to a single component, but a component can have multiple ports. Ports can be receiving ports, sending ports or bi-directional ports. They can have an arbitrary bitwidth, yet the bitwidth supported by the microblaze as well as the arm processor is limited to 32-bit. Also, the total number of ports is restricted in the microblaze / arm. We allow an arbitrary bitwidth and port number to retain generality of the driver for other platforms, but support arbitrary bidwidth translation and port number restriction to hide complexity from the user. The same applies for encoding format, i.e. the order of bits.

\subsection{Communication Interface}
The communication interface is hidden from the user. Each component has exactly one such interface. The communication interface wraps all communication between host software and board software. The interface abstracts from the physical network interface and provides a homogeneous api for components and ports. Network interface specific initialisation is generated as well and is not required by the user (other than annotating configuration details in the board description).

Note, that a board is also only allowed to use a single interface. Consequently, components using the same interface are physically located on the same board and components using different interfaces are on different boards.

Currently, three communication interfaces are envisioned:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{Ethernet Lite}, which is already implemented
\item \textbf{USB/UART}, which is considered as second interface and
\item \textbf{PCI Express}, which will not be implemented in the initial driver generator.
\end{itemize}

\paragraph{Ethernet Lite}
Communication over Ethernet is based on the lightweight IP stack, originally developed by Adam Dunkels\footnote{The lwip stack is documented with a wiki available at \url{http://lwip.wikia.com/wiki/LwIP_Wiki}}.

It is possible to implement more efficient Ethernet communication using dedicated VHDL components instead of running the lwip stack on the general purpose CPU. Such a component could easily be integrated in form of a new Communication Interface. An example for a dedicated VHDL communication component together with a client API is described in \cite{alachiotis10, alachiotis12}.

\textcolor{red}{Describe implementation of general interface methods in Ethernet as well as challenges and problems this interface poses.}

\paragraph{PCI Express}
\textcolor{red}{According to \cite{alachiotis10}, there exists a Xilinx wrapper for PCIE communication.}

\section{Board Side}
The board-side driver consists of several files that can roughly be split into three groups: files handling communication with the host-side driver, files handling communication with board components and setup files.

All these files have to be imported in a new Xilinx SDK project started from an existing XPS project. The \texttt{.elf} file generated from this project then has to be uploaded to the target board.

\paragraph{Medium}
The medium folder contains a source and header file for the medium the board is attached to. In this file, medium-specific setup is performed and listening to incoming messages is handled. An incoming message is passed to the protocol interpreter, which distributes the content of the message in accordance to its header.

\paragraph{Components}
The components folder contains code for component-specific setup and communication between the boards general purpose cpu and designed IP cores. Code for controlling gpio components will also be generated in this folder.

\paragraph{Initialisation}
Files for initialisation are generated directly in the \texttt{src} folder of the project. Among these files is the \texttt{main.c}, which calls the initialisation procedures of the medium and all components and starts the listening loop.

\newpage
\section{Protocol}

Note: These calculi denote state transitions of a DFA. The precondition marks several conditions and an in-going message. The postcondition may contain an out-going message. Used messages are:
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{rcv} Receive values for a component from application
\item \textbf{snd} Send values for a component to board
\item \textbf{ack} Receive ack for values from board
\item \textbf{poll} Receive poll from board
\end{itemize}

In addition, several functions have been used to simplify the calclui.
\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \textbf{size(q)} The size of a value queue q
\item \textbf{drop(q, i)} Drops the first i values of a queue q
\item \textbf{first(q, i)} Obtain the first i values of a queue q. Returns a smaller array, if size(q) \textless ~i
\end{itemize}

The state is denoted by an array of value queues \textit{q} and an array of transit values \textit{s}. Both arrays are sized by the number of existing board components. The queues store values that should be received by the board, the transit values store the number of values currently in transit, i.e. that have been sent but not yet been acknowledged by the board.

\begin{mathpar}
\inferrule* [left=Receive First] {q[a] = \emptyset \\ s[a] = 0 \\ rcv(a, v)}{q[a] = v \\ s[a] = size(first(v, n)) \\ snd(a, first(v, n))} \\ % initially empty queues, if something is received send the first n values and set s[a] to the number of sent values
\inferrule* [left=Receive More] {q[a] = v \\ rcv(a, v')}{q[a] = v \oplus v'} \\ % append further received values to queue

\inferrule* [left=Ack Full] {q[a] = v \\ s[a] = size(v) \\ ack(a, size(v))}{q[a] = \emptyset \\ s[a] = 0} \\% nothing more to send --> done
\inferrule* [left=Ack All] {q[a] = v \\ s[a] = i \\ ack(a, i)}{q[a] = drop(v,i) \\ s[a] = size(first(v,n)) \\ snd(a, first(v,n))} \\ % this is the ugly case. We have sent some values that all got acknowledged, but have more data --> server can accept more values and will NOT poll --> we need to send more values.
\inferrule* [left=Ack Some] {q[a] = v \\ s[a] = i \\ ack(a, j) \\ j \textless i}{q[a] = drop(v,j) \\ s[a] = 0} \\ % in this case, the server buffer is full. Consequently, we don't send more values, but wait for a poll

\inferrule* [left=Poll] {q[a] = v \\ s[a] = 0 \\ poll(a)}{ q[a] = v \\ s[a] size(first(v, n)) \\ snd(a, first(v, n=))} \\ %compressed poll rule - send the first n values on poll, if less exists send less
\inferrule* [left=Poll Transit] {s[a] = i \\ i \textgreater 0 \\ poll(a)}{ // No Transition} % ignore polls, while data is in transit

%\inferrule* [left=Total]
%  {\inferrule* [Left=Foo]
%     {\inferrule* [Right=Bar,
%                       leftskip=2em,rightskip=2em,vdots=1.5em]
%         {a \\ a \\\\ bb \\ cc \\ dd}
%         {ee}
%       \\ ff \\ gg}
%     {hh}
%  \\
%  \inferrule* [lab=XX]{uu \\ vv}{ww}}
%  {(1)}
\end{mathpar}

\chapter{Generator}
This chapter is used to explain the code generator itself. This information is intended for future developers of the driver generator.\textcolor{red}{A reference to the third Katja report might be useful.}

\section{Used Libraries}
This section gives a short overview over the used libraries and explains what for and why they are used. These libraries are included in the repository and build jar file and require no further user interaction. Still, as the generator code depends on them, they are introduced here for future developers.

\subsection{JFlex \& CUP}
\textcolor{red}{This can be kept short with a reference to the JFlex/Cup documentation}
Flex is a scanner generator, CUP a parser generator. Both together are currently used to parse \texttt{.mhs} files into abstract syntax trees. \textcolor{red}{In future versions, they will be used to parse the DSL of the driver generator.}

\subsection{Katja}
The driver generator uses the Katja tool, developed by the Software Technology Group of the University of Kaiserslautern. This tool generates several data types\footnote{Since these data types will be described using their Katja specifications, it is strongly recommended to read through the Katja specification provided in form of three technical reports at \url{https://softech.informatik.uni-kl.de/Homepage/Katja}}. To be more specific, it provides the AST build up by the CUP parser as well as a model of the \texttt{C/C++} language described in detail in \Cref{sec:cmodel}.

\section{Generation Process}
\label{sec:genprocess}
The overall process of the driver generator is described by \Cref{fig:genprocess}. The source \texttt{.mhs} file describing the system board design is first translated into an internal representation of the board, i.e. an abstract syntax tree. This AST is used as input for the generator, which in turn outputs models of all required header- and source files. These models are translated into files by the \texttt{C/C++} unparser.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1, transform shape]
\coordinate(center);
\node[tool] (gen) at (0,0) {Generator};

\node[file, above=1cm] (ast) at (gen) {Board AST};
\node[tool, above=1cm] (parser) at (ast) {Scanner/Parser};
\node[file, above=1cm] (mhs) at (parser) {.mhs file};

%TODO there is probably a better way to draw this with tikz - but there always is a better way ;)
\node[file, below left = 1.5cm and 0cm of gen] (board3) {};
\node[file, above right = -2.8em and -9em of board3] (board2) {};
\node[file, above right = -2.8em and -9em of board2] (board1) {board files};

\node[file, below right = 1.5cm and 0cm of gen] (host3) {};
\node[file, above right = -2.8em and -9em of host3] (host2) {};
\node[file, above right = -2.8em and -9em of host2] (host1) {host files};

\node[group, fit=(board1) (board2) (board3), label={95:board side}] (board) {};
\node[group, fit=(host1) (host2) (host3), label={75:host side}] (host) {};

\draw[arr] (mhs) to node[auto] {input} (parser);
\draw[arr] (parser) to node[auto] {generates} (ast);
\draw[arr] (ast) to node[auto] {input} (gen);
\draw[arr] (gen) to node[left] {generates} (board);
\draw[arr] (gen) to node[right] {generates} (host);

\draw[arr, <->] (board) to node[below] {communicate} (host);
\end{tikzpicture}
\caption{A rough sketch of the translation process so far}
\label{fig:genprocess}
\end{figure}

\section{CModel}
\label{sec:cmodel}
%TODO completely outdated, but don't want to update this part before all changes are finalised...
The \texttt{C} model provides data types representing a \texttt{C/C++} program. Note, that the model is neither complete nor always valid, i.e. not all \texttt{C} programs can be described using this model and it is possible to specify a model not translating into valid \texttt{C}. Still, the model simplifies the process of code generation. The model is used for generating \texttt{C} as well as \texttt{C++} code.

\begin{lstlisting}[language=java, breaklines=true]
MFile ( MDocumentation doc, String name, MDefinitions defs, MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses classes )

MClass ( MDocumentation doc, MModifiers modifiers, String name, MTypes extend, MStructs structs, MEnums enums, MAttributes attributes, MMethods methods, MClasses nested )

MModifier = PRIVATE() | PUBLIC() | CONSTANT() | STATIC() | INLINE()
\end{lstlisting}

First of all, files can be documented using an \texttt{MDocumentation} element. If the documentation is not empty, a \texttt{@file} tag is attached to indicate this as a file documentation for doxygen.  A file has a name and consists of several definitions, structures, enums, attributes and methods. Files also can contain several classes. These classes again have a name and can contain all these components including other classes. In addition, classes can contain modifiers and inherit components from other classes. Classes also can be documented.
The allowed modifiers are private, public, constant, static, and inline. Note, that not all of these modifiers are class modifiers, and several combinations of modifiers are invalid (e.g. private and public). The model relies on the developer to choose modifiers according to the modified program part.

\begin{lstlisting}[language=java, breaklines=true]
MDefinition ( MDocumentation doc, String name, String value)
MStruct ( MDocumentation doc, MModifiers modifiers, String name, MAttributes attributes )
MEnum   ( MDocumentation doc, MModifiers modifiers, String name, Strings values )
\end{lstlisting}

Definitions, structs and enums mark rather trivial tuple productions. A definition simply assigns a name to a value. %something about structs
Enums list a number of possible values. All three can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MAttribute ( MDocumentation doc, MModifiers modifiers, MAnyType type, String name, MCodeFragment initial )
MCodeFragment ( String part, MIncludes needed )
\end{lstlisting}

Attributes are similar to definitions, but are typed and may also be left unassigned, using an empty code fragment. The \texttt{MIncludes} is required if the type of the attribute is not defined within this c file itself. They also can be documented.

\begin{lstlisting}[language=java, breaklines=true]
MMethod ( MDocumentation doc, MModifiers modifiers, MReturnType returnType, String name, MParameters parameter, MCode body )

MReturnType = MAnyType | MVoid() | MNone()

MParameter ( MParamType refType, MAnyType type, String name )
MParamType  = VALUE() | REFERENCE() | CONSTREF()

MCode ( Strings lines, MIncludes needed )
\end{lstlisting}

Methods have a return type and a list of parameters. The method body is also more complex than a simple code fragment and can consist of several lines, which are not checked any further in this model. The return type can be any \texttt{C} type as well as void. For constructors in \texttt{C++}, the return type \texttt{MNone} is used. Parameters also have a type and name. Furthermore, the mode of parameter passing has to be specified.

\begin{lstlisting}[language=java, breaklines=true]
MAnyType = MType             ( String name )
         | MArrayType        ( MAnyType type, Integer length )
         | MPointerType      ( MAnyType type )
         | MConstPointerType ( MAnyType type )
\end{lstlisting}

The type system of the model supports arrays as well as (const) pointers. The basic type is the \texttt{MType}, which consists only of a string that has to reference an existing \texttt{C} type, e.g. \texttt{int}, \texttt{struct student} or \texttt{enum day}. This type can then be extended using pointer or array types. So \texttt{MArrayType(MType("int"), 5)} would mark an integer array of length 5. Note, that these types are nested semantically rather than in the same order as in \texttt{C}. Consequently, a point type of a const pointer type of type integer will be translated into \texttt{int const ** a}.

\begin{lstlisting}[language=java, breaklines=true]
MDocumentation ( Strings doc, MTags tags )

MTag = PARAM      ( String name, Strings details )
     | RETURN     ( Strings details )
     | THROWS     ( String type, Strings details )
     | DEPRECATED ( Strings details ) 
     | SEE        ( String see )
     | AUTHOR     ( String name )
     | SINCE      ( String date )
\end{lstlisting}

For generation of the API, Javadoc style documentation has to be added to the model. A \texttt{MDocumentation} element contains documentation for the following block as well as possibly several tags. Tags can be parameter or return value descriptions of a method/procedure, descriptions for exception behaviour, deprecation descriptions or references to other elements of the code. The \texttt{JAVADOC\_AUTOBRIEF} option is set in the generated doxygen config files, resulting in the first sentence (concluded by a dot and following space or newline) will be used as short description for the documented program part. Since neither the driver generator nor doxygen perform sanity checks, we rely on the user to only introduce meaningful tags for a documentation element. Note further, that the order of tags influences the order of elements in the generated API description.

\section{Unparser}
Different unparsers are used, to translate the \texttt{C} model in actual code. For each instance of the model, a header file and a corresponding source file, either \texttt{C} or \texttt{C++}, has to be generated. These unparsers are called depending on the particular instance of the model. Files intended to be loaded to the board have to be plain \texttt{C}, files intended for the client side can also be \texttt{C++} files. The unparsing itself is realized using the visitor pattern. Each visit method appends code to a string buffer depending on the visited element.

\paragraph{Header Unparser}
The header unparser is used for both, unparsing \texttt{C} as well as \texttt{C++} code. Consequently, it doesn't filter any constructs, but accepts everything specifiable with the model.

This unparser generates only signatures for all methods and only the declarations of attributes and enums. However, the header file will contain all includes referenced within the model.

\paragraph{Plain \texttt{C} Unparser}
Since plain \texttt{C} doesn't have any concept of classes, using a model with classes in this unparser will result in exceptions. Otherwise, all components and combinations are accepted. The source file will only import the corresponding header file, no other headers or sourcefiles.

\paragraph{\texttt{C++} Unparser}
For the \texttt{C++} unparser, like with the header unparser, every component and combination is allowed. The source file will only import the corresponding header file, no other headers or sourcefiles.



\addtocontents{toc}{\protect\vspace*{\fill}}

\newpage
\pagestyle{empty}
\bibliography{bib}
\bibliographystyle{splncs03}
\end{document}