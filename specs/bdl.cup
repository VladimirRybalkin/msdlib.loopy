package de.hopp.generator.frontend;

import java_cup.runtime.*;
import de.hopp.generator.exceptions.ParserError;
import de.hopp.generator.ErrorCollection;

/* Preliminaries to set up and use the scanner.  */
//init with {: scanner.init(); :};
//scan with {: return getScanner().next_token(); :};

action code {:
  void error(String message, int line, int column) {
    parser.errors.addError(new ParserError("Syntax Error: " + message, parser.filename, line));
  }

  Position pos(int line) {
     return BDL.Position(parser.filename, line);
  }
:}

parser code {:
//  protected BDLFile board = BDL.BDLFile(BDL.Imports(), BDL.Backends(), BDL.Options(), BDL.DEFAULT(), BDL.Medium("", ""), BDL.Cores(), BDL.GPIOs());
//
//  public BDLFile getBDLFile() {
//    return board;
//  }

  String filename;

  ErrorCollection errors;

  public void setFilename(String filename) {
    this.filename = filename;
  }

  public void setErrorCollection(ErrorCollection errors) {
    this.errors = errors;
  }

  public void report_error(String message, Object info) {

    int linenumber = -1;
    if(info instanceof Symbol) {
      Symbol symbol = (Symbol)info;
      linenumber = symbol.left;
    }
    errors.addError(new ParserError(message, filename, linenumber));
  }

  public void syntax_error(Symbol cur_token) {
//    report_error("Syntax Error in BDL file", cur_token);
  }

  public void unrecovered_syntax_error(Symbol cur_token) {
    errors.addError(new ParserError("Fatal Error: Couldn't repair and continue parse", filename, cur_token.left));
    done_parsing();
  }
:}

/* terminals */
terminal BEGIN, END, CBEGIN, COMMA;
terminal String CEND;
terminal IMPORT;
terminal BACKEND;
terminal SWQUEUE, HWQUEUE, DEBUG, WIDTH, POLL;
terminal MEDIUM, MAC, IP, MASK, GATE;
terminal CORE, SOURCE, PORT;
terminal IN, OUT, DUAL;
terminal GPIO, INSTANCE, BIND, CPU;
terminal SCHEDULER;
terminal String STRING_LITERAL;
terminal String ID, VER;
terminal Integer DEC;

/* non terminals */
non terminal BDLFile file;
non terminal Import imp;
non terminal Backend backend;
non terminal Medium medium;
non terminal Option option;
non terminal MOption medium_option;
non terminal Core core;
non terminal String version;
non terminal Import source;
non terminal Port port;
non terminal Instance instance;
non terminal GPIO gpio;
non terminal Bindings bind;
non terminal Scheduler scheduler;

non terminal Decl decl;
non terminal Decls decl_list;
non terminal Imports source_list;
non terminal Ports port_list;
non terminal Bindings bind_block, bind_list_part, cpu_bind_list_part;
non terminal Code code_block;
non terminal Options option_list, option_list_part;
non terminal MOptions medium_option_list, medium_option_list_part;
non terminal Direction direct;


/* grammar */
start with file;

file ::=
     decl_list:l
     {:
         Imports imports     = BDL.Imports();
         Backends backends   = BDL.Backends();
         Options opts        = BDL.Options();
         Cores cores         = BDL.Cores();
         GPIOs gpios         = BDL.GPIOs();
         Instances insts     = BDL.Instances();
         Medium medium       = BDL.NONE();
         Scheduler scheduler = BDL.Scheduler(pos(-1), BDL.DEFAULT());
         for(Decl d : l) {
                if(d == null) continue;
           else if(d instanceof Import)   {  imports =  imports.add((Import)d);   }
           else if(d instanceof Backend)  { backends = backends.add((Backend)d);  }
           else if(d instanceof Option)   {     opts =     opts.add((Option)d);   }
           else if(d instanceof Core)     {    cores =    cores.add((Core)d);     }
           else if(d instanceof Instance) {    insts =    insts.add((Instance)d); }
           else if(d instanceof GPIO)     {    gpios =    gpios.add((GPIO)d);     }
           else if(d instanceof Medium)   {
             // TODO catch duplicates?
             // check, if the medium is already defined. If so, throw exception
             medium = (Medium)d;
           }
           else if(d instanceof Scheduler) {
             if(scheduler instanceof USER_DEFINED) error("Duplicate Scheduler", lleft, lright);
             scheduler = (Scheduler)d;
           }
         }
         RESULT = BDL.BDLFile(imports, backends, opts, cores, gpios, insts, medium, scheduler);
     :}
  ;

decl_list ::=
     decl:d decl_list:l
     {:
         if(d == null) RESULT = l;
         else RESULT = l.appFront(d);
     :}
  |
     {:
         RESULT = BDL.Decls();
     :}
  ;

decl ::=
     imp:i       {: RESULT = i; :}
  |  backend:b   {: RESULT = b; :}
  |  option:o    {: RESULT = o; :}
  |  core:c      {: RESULT = c; :}
  |  instance:i  {: RESULT = i; :}
  |  gpio:g      {: RESULT = g; :}
  |  medium:m    {: RESULT = m; :}
  |  scheduler:s {: RESULT = s; :}
  ;

imp ::=
     IMPORT STRING_LITERAL:imp
     {:
         RESULT = BDL.Import(imp, pos(impleft));
     :}
  ;

backend ::=
     BACKEND ID:id STRING_LITERAL:content 
     {:
         RESULT = BDL.Backend(id, content, pos(idleft));
     :}
  ;

option_list ::=
     BEGIN option_list_part:l END
     {:
         RESULT = l;
     :}
  |
     {:
         RESULT = BDL.Options();
     :}
  ;

option_list_part ::=
     option:o option_list_part:l
     {:
         RESULT = l.appFront(o);
     :}
  |
     {:
         RESULT = BDL.Options();
     :}
  ;

option ::=
     SWQUEUE:key DEC:val
     {:
         RESULT = BDL.SWQUEUE(pos(keyleft),val);
     :}
  |  HWQUEUE:key DEC:val
     {:
         RESULT = BDL.HWQUEUE(pos(keyleft),val);
     :}
  |  WIDTH:key DEC:val
     {:
         RESULT = BDL.BITWIDTH(pos(keyleft),val);
     :}
  |  POLL:key DEC:val
     {:
         RESULT = BDL.POLL(pos(keyleft), val);
     :}

  |  POLL:key
     {:
         RESULT = BDL.POLL(pos(keyleft), 0);
     :}
  |  DEBUG:key
     {:
         RESULT = BDL.DEBUG(pos(keyleft));
     :}
  ;

core ::=
     CORE ID:id version:v BEGIN source_list:s port_list:p END
     {:
         RESULT = BDL.Core(id, v, pos(idleft), s, p);
     :}
  |  CORE:c error END
     {:
         error("expected core identifier after keyword", cleft, cright); 
     :}
  |  CORE:c ID error END
     {:
         error("expected version string after core identifier", cleft, cright);
     :}
  |  CORE:c ID version BEGIN error END
     {:
         error("core declaration requires at least one source reference before the port list", cleft, cright);
     :}
  ;

version ::=
     DEC:a VER:b VER:c
     {:
         RESULT = String.valueOf(a) + b + c;
     :}
  ;

source_list ::=
     source:s source_list:l
     {:
         RESULT = l.appFront(s);
     :}
  |  source:s
     {:
         RESULT = BDL.Imports(s);
     :}
  ;

source ::=
     SOURCE STRING_LITERAL:path
     {:
         RESULT = BDL.Import(path, pos(pathleft));
     :}
  |  SOURCE:s error
     {:
         error("source attribute is missing path", sleft, sright);
     :}
  ;

port_list ::=
     port:p port_list:l
     {:
         RESULT = l.appFront(p);
     :}
  |
     {:
         RESULT = BDL.Ports();
     :}
  ;

port   ::=
     PORT direct:d ID:id option_list:opts
     {: 
         RESULT = BDL.Port(id, d, pos(idleft), opts);
     :}
  |  PORT:p ID option_list
     {:
         error("port is missing a valid direction specifier", pleft, pright);
     :}
  |  PORT:p direct option_list
     {:
         error("port is missing an identifier", pleft, pright);
     :}
  ;

gpio ::=
     GPIO direct:d ID:id code_block:cb
     {:
         RESULT = BDL.GPIO(id, d, pos(idleft), cb);
     :}
  |  GPIO:g ID code_block
     {:
         error("GPIO specification is missing a valid direction specifier", gleft, gright);
     :}
  |  GPIO:g direct code_block
     {:
         error("GPIO specification is missing an identifier", gleft, gright);
     :}
  ;

direct ::=
     IN   {: RESULT = BDL.IN();   :}
  |  OUT  {: RESULT = BDL.OUT();  :}
  |  DUAL {: RESULT = BDL.DUAL(); :}
//  |  ID:i
//     {:
//         error("unknown direction specifier \"" + i + "\"", ileft, iright); RESULT = BDL.IN();
//     :}
  ;

instance ::=
     INSTANCE ID:core version:ver ID:id bind_block:b
     {:
         RESULT = BDL.Instance(id, core, ver, pos(idleft), b);
     :}
  ;

bind_block ::=
     BEGIN bind_list_part:l END
     {:
         RESULT = l;
     :}
  |
     {:
         RESULT = BDL.Bindings();
     :}
  ;

bind_list_part ::=
     bind:b bind_list_part:l
     {:
         RESULT = b.addAll(l);
     :}
  |
     {:
         RESULT = BDL.Bindings();
     :}
  ;

bind ::=
     BIND ID:port ID:axis option_list:opts
     {:
         RESULT = BDL.Bindings(BDL.Axis(axis, port, pos(portleft), opts));
     :}
  |
     BIND:b ID:port option_list:opts
     {:
         error("axis declaration missing port/axis identifier. Use \"cpu\" for processor connected port", bleft, bright);
         RESULT = BDL.Bindings(BDL.CPUAxis(port, pos(portleft), opts));
     :}
  |  CPU ID:port option_list:opts
     {:
         RESULT = BDL.Bindings(BDL.CPUAxis(port, pos(portleft), opts));
     :}
  |  CPU ID:port cpu_bind_list_part:l option_list:opts
     {:
         RESULT = BDL.Bindings(BDL.CPUAxis(port, pos(portleft)));
         for(Binding b : l) RESULT = RESULT.add(((CPUAxis)b).replaceOpts(opts));
     :}
  |  CPU:c ID:id1 ID:id2 option_list:opts
     {:
         error("cpu axis declaration with two identifiers. Use \"bind\" for non-processor connected ports or separate multiple processor-connected ports with comma", cleft, cright);
         RESULT = BDL.Bindings(
           BDL.CPUAxis(id1, pos(id1left)),
           BDL.CPUAxis(id2, pos(id2left))
         );
     :}
  ;

cpu_bind_list_part ::=
     COMMA ID:port cpu_bind_list_part:l
     {:
         RESULT = l.appFront(BDL.CPUAxis(port, pos(portleft)));
     :}
  |  COMMA ID:port
     {:
         RESULT = BDL.Bindings(BDL.CPUAxis(port, pos(portleft), BDL.Options()));
     :}
  ;


code_block ::=
     CBEGIN CEND:c
     {:
         RESULT = BDL.USER_DEFINED(c);
     :}
  |  CBEGIN:b error
     {:
         error("could not find matching closing code bracket", bleft, bright);
         RESULT = BDL.DEFAULT();
     :}
  |  error:e
     {:
         error("expected opening code block", eleft, eright);
         RESULT = BDL.DEFAULT();
     :}
  |
     {:
         RESULT = BDL.DEFAULT();
     :}
  ;

medium ::= // TODO
     MEDIUM ID:id medium_option_list:mol
     {:
         if(id.equals("ethernet"))  RESULT = BDL.ETHERNET(pos(idleft),mol);
         else if(id.equals("uart")) RESULT = BDL.UART(pos(idleft),mol);
         else if(id.equals("pcie")) RESULT = BDL.PCIE(pos(idleft),mol);
         else {
            error("unknown medium " + id, idleft, idright);
            RESULT = BDL.NONE();
         }
     :}
  ;

medium_option_list ::=
     BEGIN medium_option_list_part:mol END
     {:
         RESULT = mol;
     :}
  |
     {:
         RESULT = BDL.MOptions();
     :}
  ;

medium_option_list_part ::=
     medium_option:mo medium_option_list_part:mol
     {:
         RESULT = mol.appFront(mo);
     :}
  |
     {:
         RESULT = BDL.MOptions();
     :}
  ;

medium_option ::=
     MAC:key STRING_LITERAL:val
     {:
         RESULT = BDL.MAC(pos(keyleft),val);
     :}
  |  IP:key STRING_LITERAL:val
     {:
         RESULT = BDL.IP(pos(keyleft),val);
     :}
  |  MASK:key STRING_LITERAL:val
     {:
         RESULT = BDL.MASK(pos(keyleft),val);
     :}
  |  GATE:key STRING_LITERAL:val
     {:
         RESULT = BDL.GATE(pos(keyleft),val);
     :}
  |  PORT:key DEC:val
     {:
         RESULT = BDL.PORTID(pos(keyleft),val);
     :}
  ;

scheduler ::=
     SCHEDULER:s code_block:cb
     {:
         RESULT = BDL.Scheduler(pos(sleft), cb);
     :}
  ;

